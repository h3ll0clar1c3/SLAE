IA-32 Architecture:

https://i.imgur.com/Mr9pvq9.jpg

gdb /bin/bash
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /bin/bash...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x805eba6
(gdb) run 
Starting program: /bin/bash 

Breakpoint 1, 0x0805eba6 in main ()
(gdb) info registers
eax            0x1	1
ecx            0xbffff774	-1073744012
edx            0xbffff704	-1073744124
ebx            0xb7fa1ff4	-1208344588
esp            0xbffff6cc	0xbffff6cc
ebp            0xbffff6d8	0xbffff6d8
esi            0x0	0
edi            0x0	0
eip            0x805eba6	0x805eba6 <main+6>
eflags         0x246	[ PF ZF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) display /x $eax
1: /x $eax = 0x1
(gdb) display /x $ax
2: /x $ax = 0x1
(gdb) display /x $ecx
3: /x $ecx = 0xbffff774
(gdb) display /x $cx
4: /x $cx = 0xf774
(gdb) display /x $ch
5: /x $ch = 0xf7
(gdb) display /x $cl
6: /x $cl = 0x74
(gdb) info all-registers 
eax            0x1	1
ecx            0xbffff774	-1073744012
edx            0xbffff704	-1073744124
ebx            0xb7fa1ff4	-1208344588
esp            0xbffff6cc	0xbffff6cc
ebp            0xbffff6d8	0xbffff6d8
esi            0x0	0
edi            0x0	0
eip            0x805eba6	0x805eba6 <main+6>
eflags         0x246	[ PF ZF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
st0            0	(raw 0x00000000000000000000)
st1            0	(raw 0x00000000000000000000)
st2            0	(raw 0x00000000000000000000)
st3            0	(raw 0x00000000000000000000)
st4            0	(raw 0x00000000000000000000)
st5            0	(raw 0x00000000000000000000)
st6            0	(raw 0x00000000000000000000)
st7            0	(raw 0x00000000000000000000)
fctrl          0x37f	895
fstat          0x0	0
ftag           0xffff	65535
fiseg          0x0	0
fioff          0x0	0
foseg          0x0	0
fooff          0x0	0
fop            0x0	0
mxcsr          0x1f80	[ IM DM ZM OM UM PM ]
ymm0           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm1           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm2           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm3           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm4           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm5           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
---Type <return> to continue, or q <return> to quit---
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm6           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm7           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
mm0            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm1            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm2            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm3            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm4            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm5            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm6            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm7            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x0805eba0 <+0>:	push   ebp
   0x0805eba1 <+1>:	mov    ebp,esp
   0x0805eba3 <+3>:	push   edi
   0x0805eba4 <+4>:	push   esi
   0x0805eba5 <+5>:	push   ebx
=> 0x0805eba6 <+6>:	and    esp,0xfffffff0

CPU Modes and Memory Management:

cat /proc/pid/maps
pmap -d pid
gdb /bin/bash
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /bin/bash...(no debugging symbols found)...done.
(gdb) info proc mappings
No current process: you must name one.
(gdb) break main
Breakpoint 1 at 0x805eba6
(gdb) run
Starting program: /bin/bash 

Breakpoint 1, 0x0805eba6 in main ()
(gdb) info proc mappings
process 6099
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8124000    0xdc000        0x0 /bin/bash
	 0x8124000  0x8125000     0x1000    0xdb000 /bin/bash
	 0x8125000  0x812a000     0x5000    0xdc000 /bin/bash
	 0x812a000  0x812f000     0x5000        0x0 [heap]
	0xb7dfa000 0xb7dfb000     0x1000        0x0 
	0xb7dfb000 0xb7f9f000   0x1a4000        0x0 /lib/i386-linux-gnu/libc-2.15.so
	0xb7f9f000 0xb7fa0000     0x1000   0x1a4000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fa0000 0xb7fa2000     0x2000   0x1a4000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fa2000 0xb7fa3000     0x1000   0x1a6000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fa3000 0xb7fa7000     0x4000        0x0 
	0xb7fa7000 0xb7faa000     0x3000        0x0 /lib/i386-linux-gnu/libdl-2.15.so
	0xb7faa000 0xb7fab000     0x1000     0x2000 /lib/i386-linux-gnu/libdl-2.15.so
	0xb7fab000 0xb7fac000     0x1000     0x3000 /lib/i386-linux-gnu/libdl-2.15.so
	0xb7fac000 0xb7fc8000    0x1c000        0x0 /lib/i386-linux-gnu/libtinfo.so.5.9
	0xb7fc8000 0xb7fca000     0x2000    0x1b000 /lib/i386-linux-gnu/libtinfo.so.5.9
	0xb7fca000 0xb7fcb000     0x1000    0x1d000 /lib/i386-linux-gnu/libtinfo.so.5.9
	0xb7fdb000 0xb7fdd000     0x2000        0x0 
	0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]
	0xb7fde000 0xb7ffe000    0x20000        0x0 /lib/i386-linux-gnu/ld-2.15.so
	0xb7ffe000 0xb7fff000     0x1000    0x1f000 /lib/i386-linux-gnu/ld-2.15.so
	0xb7fff000 0xb8000000     0x1000    0x20000 /lib/i386-linux-gnu/ld-2.15.so
	0xbffdf000 0xc0000000    0x21000        0x0 [stack]

Hello World:

vim HelloWorld.asm

; HelloWorld.asm 
; Author: Vivek Ramachandran



global _start

section .text

_start:

        ; print hello world on the screen

        mov eax, 0x4
        mov ebx, 0x1
        mov ecx, message
        mov edx, mlen
        int 0x80


        ; exit the program gracefully

        mov eax, 0x1
        mov ebx, 0x5
        int 0x80



section .data

        message: db "Hello World!"
        mlen    equ  $-message

nasm -f elf32 -o HelloWorld.o HelloWorld.asm (Assemble)
ld -o HelloWorld HelloWorld.o (Link)
echo $? (Display return value)
5

HelloWorld GDB:

gdb ./HelloWorld 
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /SLAE x86/HelloWorld/HelloWorld...(no debugging symbols found)...done.
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run 
Starting program: /SLAE x86/HelloWorld/HelloWorld 

Breakpoint 1, 0x08048080 in _start ()
(gdb) set disassembly-flavor intel
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info registers
eax            0x0	0
ecx            0x0	0
edx            0x0	0
ebx            0x0	0
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048080	0x8048080 <_start>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x08048085 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
=> 0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info registers
eax            0x4	4
ecx            0x0	0
edx            0x0	0
ebx            0x0	0
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048085	0x8048085 <_start+5>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x0804808a in _start ()
(gdb) info registers
eax            0x4	4
ecx            0x0	0
edx            0x0	0
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x804808a	0x804808a <_start+10>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
=> 0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) x/s 0x80490a4
0x80490a4 <message>:	 "Hello World!"
(gdb) stepi
0x0804808f in _start ()
(gdb) info registers
eax            0x4	4
ecx            0x80490a4	134516900
edx            0x0	0
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x804808f	0x804808f <_start+15>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x08048094 in _start ()
(gdb) info registers
eax            0x4	4
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048094	0x8048094 <_start+20>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
=> 0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) stepi
Hello World!0x08048096 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
=> 0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info registers
eax            0xc	12
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048096	0x8048096 <_start+22>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x0804809b in _start ()
(gdb) info registers
eax            0x1	1
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x804809b	0x804809b <_start+27>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
=> 0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) stepi
0x080480a0 in _start ()
(gdb) info registers
eax            0x1	1
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x5	5
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x80480a0	0x80480a0 <_start+32>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
=> 0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) stepi
[Inferior 1 (process 8672) exited with code 05]

Data Types:

Byte - 8 bits
Word - 16 bits
Double Word - 32 bits
Quad Word - 64 bits
Double Quad Word - 128 bits

Accessing Memory Reference with []
message db 0xAA, 0xBB, 0xCC, 0xDD (db = define bytes)
mov eax, message <- moves address into eax
mov eax, [message] <- moves value into eax

Declare Uninitialized Data
resb 64 (reserve 64 bytes)
resw 1 (reserve a word)

vim DataTypes.nasm
; DataTypes.nasm
; Author: Vivek Ramachandran



global _start

section .text

_start:

        ; print hello world on the screen

        mov eax, 0x4
        mov ebx, 0x1
        mov ecx, message
        mov edx, mlen
        int 0x80

        ; exit the program gracefully

        mov eax, 0x1
        mov ebx, 0x5
        int 0x80



section .data

        var1:   db 0xAA
        var2:   db 0xBB, 0xCC, 0xDD
        var3:   dw 0xEE
        var4:   dd 0xAABBCCDD
        var5:   dd 0x112233
        var6:   TIMES 6 db 0xFF

        message: db "Hello World!"
        mlen    equ  $-message


section .bss

        var7:   resb 100
        var8:   resw 20
	
cat compile.sh 
#!/bin/bash

echo '[+] Assembling with Nasm ... '
nasm -f elf32 -o $1.o $1.nasm

echo '[+] Linking ...'
ld -o $1 $1.o

echo '[+] Done!'

./compile.sh  DataTypes
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!

gdb -q ./DataTypes
Reading symbols from /SLAE x86/DataTypes/DataTypes...(no debugging symbols found)...done.
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x08048080  _start
(gdb) shell readelf -h DataTypes
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048080
  Start of program headers:          52 (bytes into file)
  Start of section headers:          240 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         7
  Section header string table index: 4
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) set disassembly-flavor intel
(gdb) run
Starting program: /SLAE x86/DataTypes/DataTypes 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b8
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info variables
All defined variables:

Non-debugging symbols:
0x080490a4  var1
0x080490a5  var2
0x080490a8  var3
0x080490aa  var4
0x080490ae  var5
0x080490b2  var6
0x080490b8  message
0x080490c4  var7
0x08049128  var8
(gdb) x/xb 0x080490a4
0x80490a4 <var1>:	0xaa
(gdb) x/xb &var1
0x80490a4 <var1>:	0xaa
(gdb) x/3xb &var2
0x80490a5 <var2>:	0xbb	0xcc	0xdd
(gdb) x/2xb &var3
0x80490a8 <var3>:	0xee	0x00
(gdb) print &var4
$1 = (<data variable, no debug info> *) 0x80490aa
(gdb) x/xb 0x80490aa
0x80490aa <var4>:	0xdd
(gdb) x/xb 0x80490ab
0x80490ab <var4+1>:	0xcc
(gdb) x/xb 0x80490ac
0x80490ac <var4+2>:	0xbb
(gdb) x/xb 0x80490ad
0x80490ad <var4+3>:	0xaa
(gdb) print &var5
$2 = (<data variable, no debug info> *) 0x80490ae
(gdb) x/xb 0x80490ae
0x80490ae <var5>:	0x33
(gdb) x/xb 0x80490af
0x80490af <var5+1>:	0x22
(gdb) x/xb 0x80490b0
0x80490b0 <var5+2>:	0x11
(gdb) x/xb &var6
0x80490b2 <var6>:	0xff

Moving Data:

vim MovingData.nasm 

; Filename: MovingData.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        ; mov immediate data to register

        mov eax, 0xaaaaaaaa
        mov al, 0xbb
        mov ah, 0xcc
        mov ax, 0xdddd

        mov ebx, 0
        mov ecx, 0

        ; mov register to register

        mov ebx, eax
        mov cl, al
        mov ch, ah
        mov cx, ax

        mov eax, 0
        mov ebx, 0
        mov ecx, 0

        ; mov from memory into register

        mov al, [sample]
        mov ah, [sample +1]
        mov bx, [sample]
        mov ecx, [sample]

        ; mov from register into memory


        mov eax, 0x33445566
        mov byte [sample], al
        mov word [sample], ax
        mov dword [sample], eax

        ; mov immediate value into memory

        mov dword [sample], 0x33445566

        ; lea demo

        lea eax, [sample]
        lea ebx, [eax]


        ; xchg demo
        mov eax, 0x11223344
        mov ebx, 0xaabbccdd

        xchg eax, ebx


        ; exit the program gracefully

        mov eax, 1
        mov ebx, 0
        int 0x80


section .data

sample: db 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x22

./compile.sh MovingData
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./MovingData
Reading symbols from /SLAE x86/MovingData/MovingData...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/MovingData/MovingData 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0xaaaaaaaa
   0x08048085 <+5>:	mov    al,0xbb
   0x08048087 <+7>:	mov    ah,0xcc
   0x08048089 <+9>:	mov    ax,0xdddd
   0x0804808d <+13>:	mov    ebx,0x0
   0x08048092 <+18>:	mov    ecx,0x0
   0x08048097 <+23>:	mov    ebx,eax
   0x08048099 <+25>:	mov    cl,al
   0x0804809b <+27>:	mov    ch,ah
   0x0804809d <+29>:	mov    cx,ax
   0x080480a0 <+32>:	mov    eax,0x0
   0x080480a5 <+37>:	mov    ebx,0x0
   0x080480aa <+42>:	mov    ecx,0x0
   0x080480af <+47>:	mov    al,ds:0x8049108
   0x080480b4 <+52>:	mov    ah,BYTE PTR ds:0x8049109
   0x080480ba <+58>:	mov    bx,WORD PTR ds:0x8049108
   0x080480c1 <+65>:	mov    ecx,DWORD PTR ds:0x8049108
   0x080480c7 <+71>:	mov    eax,0x33445566
   0x080480cc <+76>:	mov    ds:0x8049108,al
   0x080480d1 <+81>:	mov    ds:0x8049108,ax
   0x080480d7 <+87>:	mov    ds:0x8049108,eax
   0x080480dc <+92>:	mov    DWORD PTR ds:0x8049108,0x33445566
   0x080480e6 <+102>:	lea    eax,ds:0x8049108
   0x080480ec <+108>:	lea    ebx,[eax]
   0x080480ee <+110>:	mov    eax,0x11223344
   0x080480f3 <+115>:	mov    ebx,0xaabbccdd
   0x080480f8 <+120>:	xchg   ebx,eax
   0x080480f9 <+121>:	mov    eax,0x1
   0x080480fe <+126>:	mov    ebx,0x0
   0x08048103 <+131>:	int    0x80
End of assembler dump.
(gdb) x/8xb &sample
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print /x $eax
>print /x $ebx
>print /x $ecx
>x/8xb &sample
>disassemble $eip,+10
>end
(gdb) disassemble $eip,+10
Dump of assembler code from 0x8048080 to 0x804808a:
=> 0x08048080 <_start+0>:	mov    eax,0xaaaaaaaa
   0x08048085 <_start+5>:	mov    al,0xbb
   0x08048087 <_start+7>:	mov    ah,0xcc
   0x08048089 <_start+9>:	mov    ax,0xdddd
End of assembler dump.
(gdb) nexti
$2 = 0xaaaaaaaa
$3 = 0x0
$4 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048085 to 0x804808f:
=> 0x08048085 <_start+5>:	mov    al,0xbb
   0x08048087 <_start+7>:	mov    ah,0xcc
   0x08048089 <_start+9>:	mov    ax,0xdddd
   0x0804808d <_start+13>:	mov    ebx,0x0
End of assembler dump.
0x08048085 in _start ()
(gdb) 
$5 = 0xaaaaaabb
$6 = 0x0
$7 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048087 to 0x8048091:
=> 0x08048087 <_start+7>:	mov    ah,0xcc
   0x08048089 <_start+9>:	mov    ax,0xdddd
   0x0804808d <_start+13>:	mov    ebx,0x0
End of assembler dump.
0x08048087 in _start ()
(gdb) 
$8 = 0xaaaaccbb
$9 = 0x0
$10 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048089 to 0x8048093:
=> 0x08048089 <_start+9>:	mov    ax,0xdddd
   0x0804808d <_start+13>:	mov    ebx,0x0
   0x08048092 <_start+18>:	mov    ecx,0x0
End of assembler dump.
0x08048089 in _start ()
(gdb) 
$11 = 0xaaaadddd
$12 = 0x0
$13 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x804808d to 0x8048097:
=> 0x0804808d <_start+13>:	mov    ebx,0x0
   0x08048092 <_start+18>:	mov    ecx,0x0
End of assembler dump.
0x0804808d in _start ()
(gdb) 
$14 = 0xaaaadddd
$15 = 0x0
$16 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048092 to 0x804809c:
=> 0x08048092 <_start+18>:	mov    ecx,0x0
   0x08048097 <_start+23>:	mov    ebx,eax
   0x08048099 <_start+25>:	mov    cl,al
   0x0804809b <_start+27>:	mov    ch,ah
End of assembler dump.
0x08048092 in _start ()
(gdb) 
$17 = 0xaaaadddd
$18 = 0x0
$19 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048097 to 0x80480a1:
=> 0x08048097 <_start+23>:	mov    ebx,eax
   0x08048099 <_start+25>:	mov    cl,al
   0x0804809b <_start+27>:	mov    ch,ah
   0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
End of assembler dump.
0x08048097 in _start ()
(gdb) 
$20 = 0xaaaadddd
$21 = 0xaaaadddd
$22 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <_start+25>:	mov    cl,al
   0x0804809b <_start+27>:	mov    ch,ah
   0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
End of assembler dump.
0x08048099 in _start ()
(gdb) 
$23 = 0xaaaadddd
$24 = 0xaaaadddd
$25 = 0xdd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x804809b to 0x80480a5:
=> 0x0804809b <_start+27>:	mov    ch,ah
   0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
End of assembler dump.
0x0804809b in _start ()
(gdb) 
$26 = 0xaaaadddd
$27 = 0xaaaadddd
$28 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x804809d to 0x80480a7:
=> 0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
   0x080480a5 <_start+37>:	mov    ebx,0x0
End of assembler dump.
0x0804809d in _start ()
(gdb) 
$29 = 0xaaaadddd
$30 = 0xaaaadddd
$31 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480a0 to 0x80480aa:
=> 0x080480a0 <_start+32>:	mov    eax,0x0
   0x080480a5 <_start+37>:	mov    ebx,0x0
End of assembler dump.
0x080480a0 in _start ()
(gdb) 
$32 = 0x0
$33 = 0xaaaadddd
$34 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <_start+37>:	mov    ebx,0x0
   0x080480aa <_start+42>:	mov    ecx,0x0
End of assembler dump.
0x080480a5 in _start ()
(gdb) 
$35 = 0x0
$36 = 0x0
$37 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480aa to 0x80480b4:
=> 0x080480aa <_start+42>:	mov    ecx,0x0
   0x080480af <_start+47>:	mov    al,ds:0x8049108
End of assembler dump.
0x080480aa in _start ()
(gdb) 
$38 = 0x0
$39 = 0x0
$40 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480af to 0x80480b9:
=> 0x080480af <_start+47>:	mov    al,ds:0x8049108
   0x080480b4 <_start+52>:	mov    ah,BYTE PTR ds:0x8049109
End of assembler dump.
0x080480af in _start ()
(gdb) 
$41 = 0xaa
$42 = 0x0
$43 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480b4 to 0x80480be:
=> 0x080480b4 <_start+52>:	mov    ah,BYTE PTR ds:0x8049109
   0x080480ba <_start+58>:	mov    bx,WORD PTR ds:0x8049108
End of assembler dump.
0x080480b4 in _start ()
(gdb) 
$44 = 0xbbaa
$45 = 0x0
$46 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480ba to 0x80480c4:
=> 0x080480ba <_start+58>:	mov    bx,WORD PTR ds:0x8049108
   0x080480c1 <_start+65>:	mov    ecx,DWORD PTR ds:0x8049108
End of assembler dump.
0x080480ba in _start ()
(gdb) 
$47 = 0xbbaa
$48 = 0xbbaa
$49 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480c1 to 0x80480cb:
=> 0x080480c1 <_start+65>:	mov    ecx,DWORD PTR ds:0x8049108
   0x080480c7 <_start+71>:	mov    eax,0x33445566
End of assembler dump.
0x080480c1 in _start ()
(gdb) 
$50 = 0xbbaa
$51 = 0xbbaa
$52 = 0xddccbbaa
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480c7 to 0x80480d1:
=> 0x080480c7 <_start+71>:	mov    eax,0x33445566
   0x080480cc <_start+76>:	mov    ds:0x8049108,al
End of assembler dump.
0x080480c7 in _start ()
(gdb) 
$53 = 0x33445566
$54 = 0xbbaa
$55 = 0xddccbbaa
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480cc to 0x80480d6:
=> 0x080480cc <_start+76>:	mov    ds:0x8049108,al
   0x080480d1 <_start+81>:	mov    ds:0x8049108,ax
End of assembler dump.
0x080480cc in _start ()
(gdb) 
$56 = 0x33445566
$57 = 0xbbaa
$58 = 0xddccbbaa
0x8049108 <sample>:	0x66	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480d1 to 0x80480db:
=> 0x080480d1 <_start+81>:	mov    ds:0x8049108,ax
   0x080480d7 <_start+87>:	mov    ds:0x8049108,eax
End of assembler dump.
0x080480d1 in _start ()
(gdb) 
$59 = 0x33445566
$60 = 0xbbaa
$61 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480d7 to 0x80480e1:
=> 0x080480d7 <_start+87>:	mov    ds:0x8049108,eax
   0x080480dc <_start+92>:	mov    DWORD PTR ds:0x8049108,0x33445566
End of assembler dump.
0x080480d7 in _start ()
(gdb) 
$62 = 0x33445566
$63 = 0xbbaa
$64 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480dc to 0x80480e6:
=> 0x080480dc <_start+92>:	mov    DWORD PTR ds:0x8049108,0x33445566
End of assembler dump.
0x080480dc in _start ()
(gdb) 
$65 = 0x33445566
$66 = 0xbbaa
$67 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480e6 to 0x80480f0:
=> 0x080480e6 <_start+102>:	lea    eax,ds:0x8049108
   0x080480ec <_start+108>:	lea    ebx,[eax]
   0x080480ee <_start+110>:	mov    eax,0x11223344
End of assembler dump.
0x080480e6 in _start ()
(gdb) 
$68 = 0x8049108
$69 = 0xbbaa
$70 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480ec to 0x80480f6:
=> 0x080480ec <_start+108>:	lea    ebx,[eax]
   0x080480ee <_start+110>:	mov    eax,0x11223344
   0x080480f3 <_start+115>:	mov    ebx,0xaabbccdd
End of assembler dump.
0x080480ec in _start ()
(gdb) 
$71 = 0x8049108
$72 = 0x8049108
$73 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480ee to 0x80480f8:
=> 0x080480ee <_start+110>:	mov    eax,0x11223344
   0x080480f3 <_start+115>:	mov    ebx,0xaabbccdd
End of assembler dump.
0x080480ee in _start ()
(gdb) 
$74 = 0x11223344
$75 = 0x8049108
$76 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480f3 to 0x80480fd:
=> 0x080480f3 <_start+115>:	mov    ebx,0xaabbccdd
   0x080480f8 <_start+120>:	xchg   ebx,eax
   0x080480f9 <_start+121>:	mov    eax,0x1
End of assembler dump.
0x080480f3 in _start ()
(gdb) 
$77 = 0x11223344
$78 = 0xaabbccdd
$79 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480f8 to 0x8048102:
=> 0x080480f8 <_start+120>:	xchg   ebx,eax
   0x080480f9 <_start+121>:	mov    eax,0x1
   0x080480fe <_start+126>:	mov    ebx,0x0
End of assembler dump.
0x080480f8 in _start ()
(gdb) 
$80 = 0xaabbccdd
$81 = 0x11223344
$82 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480f9 to 0x8048103:
=> 0x080480f9 <_start+121>:	mov    eax,0x1
   0x080480fe <_start+126>:	mov    ebx,0x0
End of assembler dump.
0x080480f9 in _start ()
(gdb) c
Continuing.
[Inferior 1 (process 16956) exited normally]
Error while running hook_stop:
No registers

Stack:

vim Stack.nasm
; Filename: Stack.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        mov eax, 0x66778899
        mov ebx, 0x0
        mov ecx, 0x0

        ; push and pop of r/m16 and r/m32

        ; register push and pop

        push ax
        pop bx

        push eax
        pop ecx

        ;  memory push and pop

        push word [sample]
        pop ecx

        push dword [sample]
        pop edx


        ; exit the program gracefully

        mov eax, 1
        mov ebx, 0
        int 0x80


section .data

sample: db 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x22

./compile.sh Stack
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./Stack
Reading symbols from /SLAE x86/MovingData/Stack...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/MovingData/Stack 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x66778899
   0x08048085 <+5>:	mov    ebx,0x0
   0x0804808a <+10>:	mov    ecx,0x0
   0x0804808f <+15>:	push   ax
   0x08048091 <+17>:	pop    bx
   0x08048093 <+19>:	push   eax
   0x08048094 <+20>:	pop    ecx
   0x08048095 <+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <+28>:	pop    ecx
   0x0804809d <+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <+35>:	pop    edx
   0x080480a4 <+36>:	mov    eax,0x1
   0x080480a9 <+41>:	mov    ebx,0x0
   0x080480ae <+46>:	int    0x80
End of assembler dump.
(gdb) display/x $eax
1: /x $eax = 0x0
(gdb) display/x $ebx
2: /x $ebx = 0x0
(gdb) display/x $ecx
3: /x $ecx = 0x0
(gdb) define hook-stop
Redefine command "hook-stop"? (y or n) y
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/8xb $esp
>x/4xh $esp
>x/3xw $esp
>disassemble $eip,+10
>end
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x66778899
   0x08048085 <+5>:	mov    ebx,0x0
   0x0804808a <+10>:	mov    ecx,0x0
   0x0804808f <+15>:	push   ax
   0x08048091 <+17>:	pop    bx
   0x08048093 <+19>:	push   eax
   0x08048094 <+20>:	pop    ecx
   0x08048095 <+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <+28>:	pop    ecx
   0x0804809d <+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <+35>:	pop    edx
   0x080480a4 <+36>:	mov    eax,0x1
   0x080480a9 <+41>:	mov    ebx,0x0
   0x080480ae <+46>:	int    0x80
End of assembler dump.
(gdb) nexti
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x8048085 to 0x804808f:
=> 0x08048085 <_start+5>:	mov    ebx,0x0
   0x0804808a <_start+10>:	mov    ecx,0x0
End of assembler dump.
0x08048085 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x804808a to 0x8048094:
=> 0x0804808a <_start+10>:	mov    ecx,0x0
   0x0804808f <_start+15>:	push   ax
   0x08048091 <_start+17>:	pop    bx
   0x08048093 <_start+19>:	push   eax
End of assembler dump.
0x0804808a in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <_start+15>:	push   ax
   0x08048091 <_start+17>:	pop    bx
   0x08048093 <_start+19>:	push   eax
   0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
End of assembler dump.
0x0804808f in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff70e:	0x99	0x88	0x01	0x00	0x00	0x00	0x36	0xf8
0xbffff70e:	0x8899	0x0001	0x0000	0xf836
0xbffff70e:	0x00018899	0xf8360000	0x0000bfff
Dump of assembler code from 0x8048091 to 0x804809b:
=> 0x08048091 <_start+17>:	pop    bx
   0x08048093 <_start+19>:	push   eax
   0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
End of assembler dump.
0x08048091 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x8048093 to 0x804809d:
=> 0x08048093 <_start+19>:	push   eax
   0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <_start+28>:	pop    ecx
End of assembler dump.
0x08048093 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff70c:	0x99	0x88	0x77	0x66	0x01	0x00	0x00	0x00
0xbffff70c:	0x8899	0x6677	0x0001	0x0000
0xbffff70c:	0x66778899	0x00000001	0xbffff836
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <_start+28>:	pop    ecx
   0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
End of assembler dump.
0x08048094 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x8048095 to 0x804809f:
=> 0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <_start+28>:	pop    ecx
   0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
End of assembler dump.
0x08048095 in _start ()
3: /x $ecx = 0x66778899
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) x/xh 0x80490b0
0x80490b0 <sample>:	0xbbaa
(gdb) nexti
0xbffff70e:	0xaa	0xbb	0x01	0x00	0x00	0x00	0x36	0xf8
0xbffff70e:	0xbbaa	0x0001	0x0000	0xf836
0xbffff70e:	0x0001bbaa	0xf8360000	0x0000bfff
Dump of assembler code from 0x804809c to 0x80480a6:
=> 0x0804809c <_start+28>:	pop    ecx
   0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <_start+35>:	pop    edx
   0x080480a4 <_start+36>:	mov    eax,0x1
End of assembler dump.
0x0804809c in _start ()
3: /x $ecx = 0x66778899
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x804809d to 0x80480a7:
=> 0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <_start+35>:	pop    edx
   0x080480a4 <_start+36>:	mov    eax,0x1
End of assembler dump.
0x0804809d in _start ()
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) x/xw 0x80490b0
0x80490b0 <sample>:	0xddccbbaa
(gdb) nexti
0xbffff70e:	0xaa	0xbb	0xcc	0xdd	0x00	0x00	0x36	0xf8
0xbffff70e:	0xbbaa	0xddcc	0x0000	0xf836
0xbffff70e:	0xddccbbaa	0xf8360000	0x0000bfff
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <_start+35>:	pop    edx
   0x080480a4 <_start+36>:	mov    eax,0x1
   0x080480a9 <_start+41>:	mov    ebx,0x0
End of assembler dump.
0x080480a3 in _start ()
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x80480a4 to 0x80480ae:
=> 0x080480a4 <_start+36>:	mov    eax,0x1
   0x080480a9 <_start+41>:	mov    ebx,0x0
End of assembler dump.
0x080480a4 in _start ()
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) display/x $edx
4: /x $edx = 0xddccbbaa
(gdb) nexti
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x80480a9 to 0x80480b3:
=> 0x080480a9 <_start+41>:	mov    ebx,0x0
   0x080480ae <_start+46>:	int    0x80
   0x080480b0:	stos   BYTE PTR es:[edi],al
   0x080480b1:	mov    ebx,0xffeeddcc
End of assembler dump.
0x080480a9 in _start ()
4: /x $edx = 0xddccbbaa
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x1
(gdb) nexti
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x80480ae to 0x80480b8:
=> 0x080480ae <_start+46>:	int    0x80
   0x080480b0:	stos   BYTE PTR es:[edi],al
   0x080480b1:	mov    ebx,0xffeeddcc
   0x080480b6:	adc    DWORD PTR [edx],esp
End of assembler dump.
0x080480ae in _start ()
4: /x $edx = 0xddccbbaa
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x0
1: /x $eax = 0x1
(gdb) nexti
[Inferior 1 (process 20141) exited normally]
Error while running hook_stop:
No registers.

Stack Arithmetic:


